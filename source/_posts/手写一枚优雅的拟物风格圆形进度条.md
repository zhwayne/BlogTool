layout: photo
title: 手写一枚优雅的拟物风格圆形进度条
date: 2015-06-24 14:33:41
toc: true
categories:
- iOS
tags: 
- UI
---


看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。

![](/{{path}}1.png)


<!--more-->



先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。



# 圆形底盘

这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程

现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。

{% codeblock lang:swift %}
class ElegantProgressView: UIView {
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.hexColor(0xeff8f3)
    }
}
{% endcodeblock %}

然后在`ViewController`中实例化一个`ElegantProgressView`对象。

{% codeblock lang:swift %}
class ViewController: UIViewController {
    var progressView: ElegantProgressView!

    override func viewDidLoad() {
        super.viewDidLoad()
        
        let bounds = CGRectMake(0, 0, 260, 260)
        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)
        progressView = ElegantProgressView(frame: bounds)
        progressView.center = center
        
        self.view.addSubview(progressView)
    }
}
{% endcodeblock %}

![](/{{path}}2.png)

很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。

{% codeblock lang:swift %}
override init(frame: CGRect) {
    super.init(frame: frame)
    self.backgroundColor = UIColor.hexColor(0xeff8f3)
    
    /* 添加圆角 */
    self.layer.masksToBounds = true
    self.layer.cornerRadius  = self.bounds.width / 2
}
{% endcodeblock %}

![](/{{path}}3.png)

圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。

![](/{{path}}4.png)

{% codeblock lang:swift %}
override init(frame: CGRect) {
    super.init(frame: frame)
    self.backgroundColor = UIColor.hexColor(0xeff8f3)
    
    /* 添加圆角 */
    self.layer.masksToBounds = true
    self.layer.cornerRadius  = self.bounds.width / 2
    
    // 添加 layers
    self.layoutSublayers()
}

private func layoutSublayers() {
    
    func addBottom() {  // 给底盘添加黑色和白色的内阴影
        
        let topLeftShadowLayer                    = InnerShadowLayer()
        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)
        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2
        topLeftShadowLayer.innerShadowOpacity     = 0.5
        topLeftShadowLayer.innerShadowRadius      = 5
        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)
        self.layer.addSublayer(topLeftShadowLayer)
        
        let bottomRightShadowLayer                = InnerShadowLayer()
        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)
        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2
        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor
        bottomRightShadowLayer.innerShadowRadius  = 1
        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)
        self.layer.addSublayer(bottomRightShadowLayer)
        
    }
    addBottom()
}
{% endcodeblock %}


![](/{{path}}5.png)

# 中间层

底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。

首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。

{% codeblock lang:swift %}

private func layoutSublayers() {
    ...

    func addMiddle() {
        
        let middleRectInset         = layer.bounds.width * 0.1
        
        let middleLayer             = CAShapeLayer()
        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)
        middleLayer.cornerRadius    = middleLayer.bounds.width / 2
        middleLayer.backgroundColor = UIColor.whiteColor().CGColor
        
        self.layer.addSublayer(middleLayer)
        
    }
    addMiddle()

    ...
}
{% endcodeblock %}

![](/{{path}}6.png)

然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。

{% codeblock lang:swift %}
...

middleLayer.shouldRasterize    = true
middleLayer.contentsScale      = UIScreen.mainScreen().scale
middleLayer.rasterizationScale = UIScreen.mainScreen().scale
middleLayer.shadowColor        = UIColor.blackColor().CGColor
middleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例
middleLayer.shadowRadius       = 5
middleLayer.shadowOpacity      = 0.3

...
{% endcodeblock %}

![](/{{path}}7.png)

接着设置渐变图层。

{% codeblock lang:swift %}
...

let gradient          = CAGradientLayer()
gradient.frame        = middleLayer.bounds
gradient.cornerRadius = gradient.bounds.width / 2
gradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]
gradient.locations    = [-0.15, 0.75]
gradient.startPoint   = CGPointMake(0.25, 0)
gradient.endPoint     = CGPointMake(0.75, 1)

middleLayer.addSublayer(gradient)

...
{% endcodeblock %}

![](/{{path}}8.png)

还有右下角的内阴影，我们直接加在`gradient`上。

{% codeblock lang:swift %}
...

let bottomRightShadowLayer                = InnerShadowLayer()
bottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)
bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2
bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)
bottomRightShadowLayer.innerShadowOpacity = 0.3
bottomRightShadowLayer.innerShadowRadius  = 18
gradientLayer.masksToBounds               = true
gradientLayer.addSublayer(bottomRightShadowLayer)

...
{% endcodeblock %}

![](/{{path}}9.png)

最后加上左上角的高光。

{% codeblock lang:swift %}
...

let topLeftShadowLayer               = InnerShadowLayer()
topLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)
topLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2
topLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor
topLeftShadowLayer.innerShadowRadius = 1.5
topLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)
gradientLayer.addSublayer(topLeftShadowLayer)

...
{% endcodeblock %}

![](/{{path}}10.png)

# 顶层

接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。

最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。

{% codeblock lang:swift %}
private func layoutSublayers() {
    ...

    func addTop() {
        
        let topRectInset  = layer.bounds.width * 0.25
        
        let topLayer             = CAShapeLayer()
        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)
        topLayer.cornerRadius    = topLayer.bounds.width / 2
        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor
        topLayer.masksToBounds   = true;
        
        self.layer.addSublayer(topLayer)
        
    }
    addTop()

    ...
}
{% endcodeblock %}

![](/{{path}}11.png)

之后的阴影和高光就一起写了吧。

{% codeblock lang:swift %}
...

let bottomRightShadowLayer                = InnerShadowLayer()
bottomRightShadowLayer.frame              = topLayer.bounds
bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2
bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor
bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)
bottomRightShadowLayer.innerShadowRadius  = 2
bottomRightShadowLayer.innerShadowOpacity = 0.6

topLayer.addSublayer(bottomRightShadowLayer)

/******************************************************************/

let topLeftShadowLayer                = InnerShadowLayer()
topLeftShadowLayer.frame              = topLayer.bounds
topLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2
topLeftShadowLayer.innerShadowRadius  = 15
topLeftShadowLayer.innerShadowOpacity = 0.2
topLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)

topLayer.addSublayer(topLeftShadowLayer)

...
{% endcodeblock %}

![](/{{path}}12.png)


# 文字

别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。

{% codeblock lang:swift %}
class ElegantProgressView: UIView {
    private var textLabel: UILabel!
    ...
}
{% endcodeblock %}

{% codeblock lang:swift %}
private func layoutSublayers() {
    ...
    
    func addTextLabel() {
        
        let textRectInset  = layer.bounds.width * 0.3
        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)
            
        textLabel               = UILabel(frame: frame)
        textLabel.text          = "Waiting..."
        textLabel.font = UIFont(name: "HelveticaNeue-Thin", size: 32)
        textLabel.textColor     = UIColor.hexColor(0x97aea6)
        textLabel.textAlignment = NSTextAlignment.Center
            textLabel.adjustsFontSizeToFitWidth = true
        self.addSubview(textLabel)
        
    }
    addTextLabel()
    
    ...
}
{% endcodeblock %}

![](/{{path}}13.png)

# 进度显示层

界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。

{% codeblock lang:swift %}
class ElegantProgressView: UIView {
    ...
    private var progressLayer: CAShapeLayer!
    ...
}
{% endcodeblock %}

现在我们需要做一个渐变层。在这之前先声明一个类属性。

{% codeblock lang:swift %}
private func layoutSublayers() {
    ...

    func addProgress() {
                
        let gradientLayer          = CAGradientLayer()
        gradientLayer.frame        = layer.bounds
        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2
        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]
        gradientLayer.locations    = [0, 1]
        gradientLayer.startPoint   = CGPointMake(0.25, 0)
        gradientLayer.endPoint     = CGPointMake(0.75, 1)
                
        layer.addSublayer(gradientLayer)
                
    }
    addProgress()

    ...
}
{% endcodeblock %}

![](/{{path}}14.png)

不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。

然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。

{% codeblock lang:swift %}
private func layoutSublayers() {
    ...

    func addProgress() {
        ...

        let middleRectInset = layer.bounds.width * 0.1
        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath
        
        progressLayer             = CAShapeLayer()
        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)
        progressLayer.fillColor   = UIColor.clearColor().CGColor
        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor
        progressLayer.opacity     = 0.8
        progressLayer.lineCap     = kCALineCapRound
        progressLayer.lineWidth   = middleRectInset
        progressLayer.path        = path
        progressLayer.strokeEnd   = CGFloat.min
        
        gradientLayer.mask = progressLayer

        ...
    }

    ...
}
{% endcodeblock %}

> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。

一个销魂的小点出来了。至此，界面部分完结。

![](/{{path}}15.png)


# 最后的功能

要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。

我们用一个公开的计算属性间接修改它们。

{% codeblock lang:swift %}
class ElegantProgressView: UIView {
    ...
    var progress:CGFloat {
        get { return progressLayer.strokeEnd }
        set{
            var realValue = newValue
            if realValue < CGFloat.min {
                realValue = CGFloat.min
            }
            
            CATransaction.begin()
            CATransaction.setDisableActions(false)
            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))
            CATransaction.setAnimationDuration(0.001)
            progressLayer.strokeEnd = realValue
            CATransaction.commit()
            
            if realValue <= CGFloat.min {
                textLabel.text = "Waiting..."
            }
            else if realValue == 1 {
                textLabel.text = "Done"
            }
            else {
                textLabel.text = NSString(format: "%.f%%", realValue * 100) as String
            }
        }
    }
    ...
}
{% endcodeblock %}


模拟一下下载进度：

{% codeblock lang:swift %}
dispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in
    for i in 0...100 {
        if i == 0 {
            NSThread.sleepForTimeInterval(1.5)
        }
        else if i < 40 {
            NSThread.sleepForTimeInterval(0.03)
        }
        else if i < 60 {
            NSThread.sleepForTimeInterval(0.1)
        }
        else {
            NSThread.sleepForTimeInterval(0.01)
        }
        let progress = Double(i) / 100.0
        dispatch_sync(dispatch_get_main_queue(), { () -> Void in
            self.progressView.progress = CGFloat(progress)
        })
    }
}
{% endcodeblock %}


![](/{{path}}16.gif)

---

完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）
<div class="github-widget" data-repo="zhwayne/ElegantProgress"></div>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.githubRepoWidget.min.js"></script>








