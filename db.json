{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery.githubRepoWidget.min.js","path":"js/jquery.githubRepoWidget.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author-right-white.png","path":"img/author-right-white.png","modified":1},{"_id":"themes/jacman/source/img/author-left-white.png","path":"img/author-left-white.png","modified":1},{"_id":"themes/jacman/source/img/author-left-black.png","path":"img/author-left-black.png","modified":1},{"_id":"themes/jacman/source/img/author-left-black-round.png","path":"img/author-left-black-round.png","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"1fc4b425f3932cd32b17d97462a7e05dd5664dfe","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/5.png","shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转.md","shasum":"62b90f4bed8bea01b774b10f0bbcc15f0c421fe2","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","shasum":"98f141265aa661071b3c247201b8186fc733c16b","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e","modified":1435161359000},{"_id":"source/_posts/CALayer-的-inner-shadow.md","shasum":"fc327126e407f1145dc706bb99cada84fe915248","modified":1435212239000},{"_id":"source/_posts/iOS-开发小技巧合集（不定期更新）/1.png","shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740","modified":1435161359000},{"_id":"source/_posts/iOS-开发小技巧合集（不定期更新）.md","shasum":"7a56d272d4d1a6640ac4259c0f5671a98ec86241","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条.md","shasum":"f64a606b87c0f1e8d3c86103f169023555f578f6","modified":1435210929000},{"_id":"source/about/index.md","shasum":"88d01996843e91b5c2fd23cd480b268645b2313e","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/1.png","shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/2.gif","shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","shasum":"508ec9c8baaa578b42c13176de07218df713cacb","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","shasum":"1413fcc75138333569d37fde946948111244f0a5","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","shasum":"d97b92774d4712472edcde0904c2c492dc5da754","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","shasum":"9695e75f15a94cbed88287d106cba359a8351147","modified":1435161359000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1435161359000},{"_id":"themes/jacman/README.md","shasum":"38698c732ca2c0fa48de89cfee9859bc09e74fd4","modified":1435161359000},{"_id":"themes/jacman/README_zh.md","shasum":"ee9eeb2b72e5597a3550d59d231f443d990d3115","modified":1435161359000},{"_id":"themes/jacman/_config.yml","shasum":"92456d79dce7d6bef09b79082b8ca2aa5360c080","modified":1435212121000},{"_id":"themes/jacman/languages/default.yml","shasum":"ad0de3e82c7fc238cc067ffc37359b1420aef6b3","modified":1435161359000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1435161359000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"41c112162d79b4d3f97b417c7cd6ca6d70419ef2","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"07b52001fb612d67cfc2d60f982a4e838cdf0c17","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"fd004beb8d4500afd5fb3b3871a95afa2a375f16","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"7d7055a87c84f400acb3411f3813f109ff83c55f","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1435161359000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"94ce1fb7a1143f34ac1365924b00cae64e1a111e","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1435161359000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1435161359000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1435161359000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1435161359000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1435161359000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1435161359000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1435161359000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1435161359000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1435161359000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1435161359000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1435161359000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"795eeb55d1c550c113a2980df33aaf46b0ae8a2b","modified":1435161359000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1435161359000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"1db3db00620451129587cfe69599bcedea66bf3e","modified":1435161359000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"37802815b81f0943679254adf05c1e12dc37d30b","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"6b0e46e2e3be200339197696f5aabd0871aa9952","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"2a2f6d1a33da11fe395c7bbbb2c43f540ddb73ae","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"864fba1fcb3830a9055c366a99ce5c951c2e9fe9","modified":1435161359000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1435161359000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1435161359000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1435161359000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1435161359000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1435161359000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1435161359000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1435161359000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1435161359000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1435161359000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1435161359000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1435161359000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1435161359000},{"_id":"themes/jacman/source/img/author-left-black-round.png","shasum":"4b1836eb3f2f9ace0fd9226dfafd40e083b1ecf6","modified":1435161359000},{"_id":"themes/jacman/source/img/author-left-black.png","shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0","modified":1435161359000},{"_id":"themes/jacman/source/img/author-left-white.png","shasum":"75aa47371ef275d4468a56131eea7bde5ef744cb","modified":1435161359000},{"_id":"themes/jacman/source/img/author-right-white.png","shasum":"b22c70d159f0d340f89ac40fa27ce0e497cacd67","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1435161359000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1435161359000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1435161359000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1435161359000},{"_id":"themes/jacman/source/js/jquery.githubRepoWidget.min.js","shasum":"94a141fa474ec5022f7c397b4fd3ff92405ab755","modified":1420102784000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1435161359000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/3.gif","shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06","modified":1435161359000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1435161359000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1435161359000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1435161359000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/4.gif","shasum":"451329ec285208e1f9048a8401e0e32a236636f7","modified":1435161359000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1435161359000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1435161359000},{"_id":"source/_posts/App-之间的相互跳转/6.gif","shasum":"00f0597eabad626b1a515d6d891a0d0201034765","modified":1435161359000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b","modified":1435161359000},{"_id":"public/js/totop.js","modified":1435212463203,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1435212463207,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery.githubRepoWidget.min.js","modified":1435212463209,"shasum":"94a141fa474ec5022f7c397b4fd3ff92405ab755"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1435212463212,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1435212463214,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1435212463220,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/cc-zero.svg","modified":1435212463227,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/img/cc-by.svg","modified":1435212463228,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/img/cc-by-sa.svg","modified":1435212463230,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/img/cc-by-nd.svg","modified":1435212463233,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/img/cc-by-nc.svg","modified":1435212463235,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1435212463237,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1435212463239,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/img/banner.jpg","modified":1435212463243,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author-right-white.png","modified":1435212463246,"shasum":"b22c70d159f0d340f89ac40fa27ce0e497cacd67"},{"_id":"public/img/author-left-white.png","modified":1435212463250,"shasum":"75aa47371ef275d4468a56131eea7bde5ef744cb"},{"_id":"public/img/author-left-black.png","modified":1435212463252,"shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0"},{"_id":"public/img/author-left-black-round.png","modified":1435212463254,"shasum":"4b1836eb3f2f9ace0fd9226dfafd40e083b1ecf6"},{"_id":"public/font/fontdiao.woff","modified":1435212463257,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1435212463261,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1435212463264,"shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b"},{"_id":"public/font/fontdiao.eot","modified":1435212463267,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1435212463269,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1435212463271,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1435212463276,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1435212463280,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1435212463283,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1435212463287,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1435212463290,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1435212463293,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1435212463296,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1435212463299,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1435212463302,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1435212463304,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1435212463306,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1435212463308,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1435212463310,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1435212463313,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1435212463316,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1435212463319,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1435212463322,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1435212463325,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1435212463328,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1435212463332,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1435212463335,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1435212463338,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1435212464438,"shasum":"20d71d7ad34e57cbd290a86f964b03e9a2f9ae09"},{"_id":"public/CNAME","modified":1435212464813,"shasum":"1fc4b425f3932cd32b17d97462a7e05dd5664dfe"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/1.png","modified":1435212464819,"shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/10.png","modified":1435212464825,"shasum":"508ec9c8baaa578b42c13176de07218df713cacb"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/11.png","modified":1435212464830,"shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/12.png","modified":1435212464834,"shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/13.png","modified":1435212464840,"shasum":"1413fcc75138333569d37fde946948111244f0a5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/14.png","modified":1435212464845,"shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/15.png","modified":1435212464852,"shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.gif","modified":1435212464866,"shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.mov","modified":1435212464875,"shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","modified":1435212464878,"shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/2.png","modified":1435212464881,"shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/3.png","modified":1435212464886,"shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/4.png","modified":1435212464891,"shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/5.png","modified":1435212464894,"shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/6.png","modified":1435212464896,"shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/7.png","modified":1435212464899,"shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/8.png","modified":1435212464903,"shasum":"d97b92774d4712472edcde0904c2c492dc5da754"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/9.png","modified":1435212464908,"shasum":"9695e75f15a94cbed88287d106cba359a8351147"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（不定期更新）/1.png","modified":1435212464912,"shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1-1.png","modified":1435212464916,"shasum":"98f141265aa661071b3c247201b8186fc733c16b"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1.png","modified":1435212464919,"shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/2.png","modified":1435212464922,"shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/3.png","modified":1435212464925,"shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/4.png","modified":1435212464928,"shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/5.png","modified":1435212464931,"shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e"},{"_id":"public/2015/06/23/App-之间的相互跳转/1.png","modified":1435212464934,"shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e"},{"_id":"public/2015/06/23/App-之间的相互跳转/2.gif","modified":1435212464938,"shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9"},{"_id":"public/2015/06/23/App-之间的相互跳转/3.gif","modified":1435212464942,"shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06"},{"_id":"public/2015/06/23/App-之间的相互跳转/4.gif","modified":1435212464950,"shasum":"451329ec285208e1f9048a8401e0e32a236636f7"},{"_id":"public/2015/06/23/App-之间的相互跳转/5.png","modified":1435212464954,"shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8"},{"_id":"public/2015/06/23/App-之间的相互跳转/6.gif","modified":1435212464961,"shasum":"00f0597eabad626b1a515d6d891a0d0201034765"},{"_id":"public/about/index.html","modified":1435212465017,"shasum":"9ac1114d3fb0cc84ea7f08fa64d3791798c8342a"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/index.html","modified":1435212465147,"shasum":"f6a8999157e55aec6e2a52491250b07161ceb9fe"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/index.html","modified":1435212465180,"shasum":"a3f289dab86951a23292c9be088198bdf95ae7df"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（不定期更新）/index.html","modified":1435212465226,"shasum":"856d7d2357c42ee215128ad8534bc810659ccdb0"},{"_id":"public/2015/06/23/App-之间的相互跳转/index.html","modified":1435212465256,"shasum":"cf22ad18b53ddb383eab009815068dccb4e5ed92"},{"_id":"public/archives/index.html","modified":1435212465275,"shasum":"7e8fdcdad14660028b51962f7c570f4aa97c155a"},{"_id":"public/archives/2015/index.html","modified":1435212465288,"shasum":"bd3a877cbbbd5747af6ec14bf0b96ce1d473b2d4"},{"_id":"public/archives/2015/06/index.html","modified":1435212465307,"shasum":"21275f0fcea93560efbd01bcde23e9948aa3ff52"},{"_id":"public/categories/iOS/index.html","modified":1435212465337,"shasum":"a1695a51e45da4ee0f814446e5238ea5422c2130"},{"_id":"public/index.html","modified":1435212465360,"shasum":"17c38e743eec65f0a18c31725266fe716712bfc7"},{"_id":"public/tags/UI/index.html","modified":1435212465370,"shasum":"a379b4c83dfdab7bcdf16de83d3371d38f34a516"},{"_id":"public/tags/App/index.html","modified":1435212465379,"shasum":"a8399d320fe5602c4b5a8b9b3979ed7e417259c3"}],"Category":[{"name":"iOS","_id":"cibbsfzg600029k2fpfxb8tsq"}],"Data":[],"Page":[{"title":"About","date":"2015-06-24T14:21:12.000Z","_content":"\n","source":"about/index.md","raw":"title: About\ndate: 2015-06-24 22:21:12\n---\n\n","updated":"2015-06-24T15:55:59.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cibbsfzfw00009k2fwl96dwhz"}],"Post":[{"layout":"photo","title":"手写一枚优雅的拟物风格圆形进度条","date":"2015-06-24T06:33:41.000Z","toc":true,"_content":"\n\n\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","source":"_posts/手写一枚优雅的拟物风格圆形进度条.md","raw":"layout: photo\ntitle: 手写一枚优雅的拟物风格圆形进度条\ndate: 2015-06-24 14:33:41\ntoc: true\ncategories:\n- iOS\ntags: \n- UI\n---\n\n\n\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","slug":"手写一枚优雅的拟物风格圆形进度条","published":1,"updated":"2015-06-25T05:42:09.000Z","comments":1,"photos":[],"link":"","_id":"cibbsfzg100019k2f06vluxzo"},{"title":"iOS-开发小技巧合集（不定期更新）","date":"2015-06-23T11:18:31.000Z","toc":true,"_content":"\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","source":"_posts/iOS-开发小技巧合集（不定期更新）.md","raw":"title: iOS-开发小技巧合集（不定期更新）\ndate: 2015-06-23 19:18:31\ntoc: true\ncategories:\n- iOS\ntags: \n- App\n---\n\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","slug":"iOS-开发小技巧合集（不定期更新）","published":1,"updated":"2015-06-24T15:55:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibbsfzia00069k2fmf4h0gsw"},{"title":"CALayer 的 inner shadow","date":"2015-06-24T05:22:09.000Z","toc":false,"_content":"\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","source":"_posts/CALayer-的-inner-shadow.md","raw":"title: CALayer 的 inner shadow\ndate: 2015-06-24 13:22:09\ntoc: false\ncategories:\n- iOS\ntags: \n- UI\n---\n\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","slug":"CALayer-的-inner-shadow","published":1,"updated":"2015-06-25T06:03:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibbsfzii000a9k2fs9dqj5th"},{"title":"App 之间的相互跳转","date":"2015-06-23T05:05:02.000Z","_content":"\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","source":"_posts/App-之间的相互跳转.md","raw":"title: App 之间的相互跳转\ndate: 2015-06-23 13:05:02\ncategories:\n- iOS\ntags: \n- App\n---\n\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","slug":"App-之间的相互跳转","published":1,"updated":"2015-06-24T15:55:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibbsfzj9000d9k2fpwk7qjtw"}],"PostAsset":[{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","post":"cibbsfzg100019k2f06vluxzo","slug":"1.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","post":"cibbsfzg100019k2f06vluxzo","slug":"10.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","post":"cibbsfzg100019k2f06vluxzo","slug":"11.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","post":"cibbsfzg100019k2f06vluxzo","slug":"12.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","post":"cibbsfzg100019k2f06vluxzo","slug":"13.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","post":"cibbsfzg100019k2f06vluxzo","slug":"14.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","post":"cibbsfzg100019k2f06vluxzo","slug":"15.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","post":"cibbsfzg100019k2f06vluxzo","slug":"16.gif","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","post":"cibbsfzg100019k2f06vluxzo","slug":"16.mov","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","post":"cibbsfzg100019k2f06vluxzo","slug":"16_mov_poster.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","post":"cibbsfzg100019k2f06vluxzo","slug":"2.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","post":"cibbsfzg100019k2f06vluxzo","slug":"3.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","post":"cibbsfzg100019k2f06vluxzo","slug":"4.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","post":"cibbsfzg100019k2f06vluxzo","slug":"5.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","post":"cibbsfzg100019k2f06vluxzo","slug":"6.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","post":"cibbsfzg100019k2f06vluxzo","slug":"7.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","post":"cibbsfzg100019k2f06vluxzo","slug":"8.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","post":"cibbsfzg100019k2f06vluxzo","slug":"9.png","modified":1},{"_id":"source/_posts/iOS-开发小技巧合集（不定期更新）/1.png","post":"cibbsfzia00069k2fmf4h0gsw","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"1-1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"2.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"3.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"4.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","post":"cibbsfzii000a9k2fs9dqj5th","slug":"5.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/1.png","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"1.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/2.gif","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"2.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/3.gif","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"3.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/4.gif","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"4.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/5.png","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"5.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/6.gif","post":"cibbsfzj9000d9k2fpwk7qjtw","slug":"6.gif","modified":1}],"PostCategory":[{"post_id":"cibbsfzg100019k2f06vluxzo","category_id":"cibbsfzg600029k2fpfxb8tsq","_id":"cibbsfzg800059k2f8zfwcfd6"},{"post_id":"cibbsfzia00069k2fmf4h0gsw","category_id":"cibbsfzg600029k2fpfxb8tsq","_id":"cibbsfzic00079k2fw8233856"},{"post_id":"cibbsfzii000a9k2fs9dqj5th","category_id":"cibbsfzg600029k2fpfxb8tsq","_id":"cibbsfzik000b9k2f5hn2ppbw"},{"post_id":"cibbsfzj9000d9k2fpwk7qjtw","category_id":"cibbsfzg600029k2fpfxb8tsq","_id":"cibbsfzja000e9k2fvf1m9953"}],"PostTag":[{"post_id":"cibbsfzg100019k2f06vluxzo","tag_id":"cibbsfzg600039k2fw9otaolx","_id":"cibbsfzg800049k2ftdt7ndof"},{"post_id":"cibbsfzia00069k2fmf4h0gsw","tag_id":"cibbsfzic00089k2fs5k3l0qq","_id":"cibbsfzid00099k2fowbhkpbm"},{"post_id":"cibbsfzii000a9k2fs9dqj5th","tag_id":"cibbsfzg600039k2fw9otaolx","_id":"cibbsfzil000c9k2frnmkv4pq"},{"post_id":"cibbsfzj9000d9k2fpwk7qjtw","tag_id":"cibbsfzic00089k2fs5k3l0qq","_id":"cibbsfzja000f9k2fb5pctjhi"}],"Tag":[{"name":"UI","_id":"cibbsfzg600039k2fw9otaolx"},{"name":"App","_id":"cibbsfzic00089k2fs5k3l0qq"}]}}