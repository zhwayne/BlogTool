{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery.githubRepoWidget.min.js","path":"js/jquery.githubRepoWidget.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author-right-white.png","path":"img/author-right-white.png","modified":1},{"_id":"themes/jacman/source/img/author-left-white.png","path":"img/author-left-white.png","modified":1},{"_id":"themes/jacman/source/img/author-left-black.png","path":"img/author-left-black.png","modified":1},{"_id":"themes/jacman/source/img/author-left-black-round.png","path":"img/author-left-black-round.png","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/_posts/App-之间的相互跳转/5.png","shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转.md","shasum":"62b90f4bed8bea01b774b10f0bbcc15f0c421fe2","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","shasum":"98f141265aa661071b3c247201b8186fc733c16b","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow.md","shasum":"fc327126e407f1145dc706bb99cada84fe915248","modified":1435214158000},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）.md","shasum":"1b1f5ac1e30166267950fdc519a18d4b977a2c78","modified":1435545955000},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）/1.png","shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条.md","shasum":"f64a606b87c0f1e8d3c86103f169023555f578f6","modified":1435214158000},{"_id":"source/_posts/用程序解决数独是一种什么样的体验.md","shasum":"cfa0b0d446da53b882f7efcf1b429d6aa285e713","modified":1435559017000},{"_id":"source/about/index.md","shasum":"88d01996843e91b5c2fd23cd480b268645b2313e","modified":1435214158000},{"_id":"source/CNAME","shasum":"6e3b68e6d291c3f84ba6f4a777927feeb1970100","modified":1435214271000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/1.png","shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/2.gif","shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","shasum":"508ec9c8baaa578b42c13176de07218df713cacb","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","shasum":"1413fcc75138333569d37fde946948111244f0a5","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","shasum":"d97b92774d4712472edcde0904c2c492dc5da754","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","shasum":"9695e75f15a94cbed88287d106cba359a8351147","modified":1435214158000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1435214158000},{"_id":"themes/jacman/README.md","shasum":"38698c732ca2c0fa48de89cfee9859bc09e74fd4","modified":1435214158000},{"_id":"themes/jacman/README_zh.md","shasum":"ee9eeb2b72e5597a3550d59d231f443d990d3115","modified":1435214158000},{"_id":"themes/jacman/_config.yml","shasum":"92456d79dce7d6bef09b79082b8ca2aa5360c080","modified":1435214158000},{"_id":"themes/jacman/languages/default.yml","shasum":"ad0de3e82c7fc238cc067ffc37359b1420aef6b3","modified":1435214158000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1435214158000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"41c112162d79b4d3f97b417c7cd6ca6d70419ef2","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"07b52001fb612d67cfc2d60f982a4e838cdf0c17","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"fd004beb8d4500afd5fb3b3871a95afa2a375f16","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"32db7e7c8171530d29c3878f387c4438d6057508","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"7d7055a87c84f400acb3411f3813f109ff83c55f","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1435214158000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"94ce1fb7a1143f34ac1365924b00cae64e1a111e","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1435214158000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1435214158000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1435214158000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1435214158000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1435214158000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1435214158000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1435214158000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1435214158000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1435214158000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1435214158000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1435214158000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"795eeb55d1c550c113a2980df33aaf46b0ae8a2b","modified":1435214158000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1435214158000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"1db3db00620451129587cfe69599bcedea66bf3e","modified":1435214158000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"37802815b81f0943679254adf05c1e12dc37d30b","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"6b0e46e2e3be200339197696f5aabd0871aa9952","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"2a2f6d1a33da11fe395c7bbbb2c43f540ddb73ae","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"864fba1fcb3830a9055c366a99ce5c951c2e9fe9","modified":1435214158000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1435214158000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1435214158000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1435214158000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1435214158000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1435214158000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1435214158000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1435214158000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1435214158000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1435214158000},{"_id":"themes/jacman/source/img/author-left-black-round.png","shasum":"4b1836eb3f2f9ace0fd9226dfafd40e083b1ecf6","modified":1435214158000},{"_id":"themes/jacman/source/img/author-left-black.png","shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0","modified":1435214158000},{"_id":"themes/jacman/source/img/author-left-white.png","shasum":"75aa47371ef275d4468a56131eea7bde5ef744cb","modified":1435214158000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1435214158000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1435214158000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1435214158000},{"_id":"themes/jacman/source/img/author-right-white.png","shasum":"b22c70d159f0d340f89ac40fa27ce0e497cacd67","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1435214158000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1435214158000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1435214158000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1435214158000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1435214158000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1435214158000},{"_id":"themes/jacman/source/js/jquery.githubRepoWidget.min.js","shasum":"94a141fa474ec5022f7c397b4fd3ff92405ab755","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/3.gif","shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06","modified":1435214158000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1435214158000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1435214158000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1435214158000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/4.gif","shasum":"451329ec285208e1f9048a8401e0e32a236636f7","modified":1435214158000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1435214158000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/6.gif","shasum":"00f0597eabad626b1a515d6d891a0d0201034765","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b","modified":1435214158000},{"_id":"public/js/totop.js","modified":1435559026318,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1435559026323,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery.githubRepoWidget.min.js","modified":1435559026327,"shasum":"94a141fa474ec5022f7c397b4fd3ff92405ab755"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1435559026329,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1435559026336,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1435559026340,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/cc-zero.svg","modified":1435559026344,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/img/cc-by.svg","modified":1435559026346,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/img/cc-by-sa.svg","modified":1435559026347,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/img/cc-by-nd.svg","modified":1435559026349,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/img/cc-by-nc.svg","modified":1435559026351,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1435559026353,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1435559026356,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/img/banner.jpg","modified":1435559026360,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author-right-white.png","modified":1435559026362,"shasum":"b22c70d159f0d340f89ac40fa27ce0e497cacd67"},{"_id":"public/img/author-left-white.png","modified":1435559026364,"shasum":"75aa47371ef275d4468a56131eea7bde5ef744cb"},{"_id":"public/img/author-left-black.png","modified":1435559026366,"shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0"},{"_id":"public/img/author-left-black-round.png","modified":1435559026368,"shasum":"4b1836eb3f2f9ace0fd9226dfafd40e083b1ecf6"},{"_id":"public/font/fontdiao.woff","modified":1435559026369,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1435559026372,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1435559026376,"shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b"},{"_id":"public/font/fontdiao.eot","modified":1435559026381,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1435559026384,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1435559026386,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1435559026390,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/font/fontawesome-webfont.eot","modified":1435559026393,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1435559026396,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1435559026399,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1435559026402,"shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1435559026404,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1435559026406,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1435559026408,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1435559026411,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1435559026413,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1435559026415,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1435559026418,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1435559026419,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1435559026423,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1435559026427,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1435559026430,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1435559026433,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1435559026436,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1435559026439,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1435559026444,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1435559026446,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1435559026449,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1435559027407,"shasum":"20d71d7ad34e57cbd290a86f964b03e9a2f9ae09"},{"_id":"public/CNAME","modified":1435559027845,"shasum":"6e3b68e6d291c3f84ba6f4a777927feeb1970100"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/1.png","modified":1435559027848,"shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/10.png","modified":1435559027853,"shasum":"508ec9c8baaa578b42c13176de07218df713cacb"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/11.png","modified":1435559027857,"shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/12.png","modified":1435559027862,"shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/13.png","modified":1435559027866,"shasum":"1413fcc75138333569d37fde946948111244f0a5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/14.png","modified":1435559027870,"shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/15.png","modified":1435559027882,"shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.gif","modified":1435559027894,"shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.mov","modified":1435559027901,"shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","modified":1435559027904,"shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/2.png","modified":1435559027908,"shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/3.png","modified":1435559027911,"shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/4.png","modified":1435559027913,"shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/5.png","modified":1435559027916,"shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/6.png","modified":1435559027919,"shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/7.png","modified":1435559027923,"shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/8.png","modified":1435559027927,"shasum":"d97b92774d4712472edcde0904c2c492dc5da754"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/9.png","modified":1435559027932,"shasum":"9695e75f15a94cbed88287d106cba359a8351147"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（随时更新）/1.png","modified":1435559027936,"shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1-1.png","modified":1435559027939,"shasum":"98f141265aa661071b3c247201b8186fc733c16b"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1.png","modified":1435559027942,"shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/2.png","modified":1435559027945,"shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/3.png","modified":1435559027948,"shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/4.png","modified":1435559027952,"shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/5.png","modified":1435559027956,"shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e"},{"_id":"public/2015/06/23/App-之间的相互跳转/1.png","modified":1435559027960,"shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e"},{"_id":"public/2015/06/23/App-之间的相互跳转/2.gif","modified":1435559027965,"shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9"},{"_id":"public/2015/06/23/App-之间的相互跳转/3.gif","modified":1435559027971,"shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06"},{"_id":"public/2015/06/23/App-之间的相互跳转/4.gif","modified":1435559027979,"shasum":"451329ec285208e1f9048a8401e0e32a236636f7"},{"_id":"public/2015/06/23/App-之间的相互跳转/5.png","modified":1435559027983,"shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8"},{"_id":"public/2015/06/23/App-之间的相互跳转/6.gif","modified":1435559027991,"shasum":"00f0597eabad626b1a515d6d891a0d0201034765"},{"_id":"public/about/index.html","modified":1435559028061,"shasum":"c80f0ea45c6910a4c2798997ade4cf32486b2696"},{"_id":"public/2015/06/26/用程序解决数独是一种什么样的体验/index.html","modified":1435559028164,"shasum":"3dddba647ad0176a59f18f036b8021c00b8717d3"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/index.html","modified":1435559028297,"shasum":"956970c2b228ed06230d953d076b427673ff489a"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/index.html","modified":1435559028318,"shasum":"4535492266a940730853ddc084a1264e1201a7d0"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（随时更新）/index.html","modified":1435559028346,"shasum":"1947a95246f8699b677b9ec957ca5af45b11a366"},{"_id":"public/2015/06/23/App-之间的相互跳转/index.html","modified":1435559028369,"shasum":"821af47d2f256ef9471041fe7c43973dbe43ff08"},{"_id":"public/archives/index.html","modified":1435559028394,"shasum":"6bd588346ded7e8e1f64f2bafb7d81fd0b2b362d"},{"_id":"public/archives/2015/index.html","modified":1435559028406,"shasum":"bde6461a784cb194ccdd5d879ae962ad0d768f5c"},{"_id":"public/archives/2015/06/index.html","modified":1435559028419,"shasum":"f8d6c2dc85be1c4fa5949a1d4a001315babef654"},{"_id":"public/categories/算法/index.html","modified":1435559028429,"shasum":"41a45bbe18376594b1b1124228bb53f19db8b134"},{"_id":"public/categories/iOS/index.html","modified":1435559028440,"shasum":"fa599ee4d011d9d4935a15ec678feeaed3cdfc9f"},{"_id":"public/index.html","modified":1435559028464,"shasum":"e36f76b63166f145c535d41a6416a26e2c783353"},{"_id":"public/tags/回溯/index.html","modified":1435559028473,"shasum":"ad9d16c68af8e68b4a16e2a75d76d9d4d3bbdbea"},{"_id":"public/tags/深度优先/index.html","modified":1435559028484,"shasum":"9811eda2a29692a1f738df8ed8ea052f7fb98f8a"},{"_id":"public/tags/UI/index.html","modified":1435559028492,"shasum":"a379b4c83dfdab7bcdf16de83d3371d38f34a516"},{"_id":"public/tags/App/index.html","modified":1435559028499,"shasum":"0a703fd1eabc9c09cfaf205cc6cc279619cc352b"}],"Category":[{"name":"算法","_id":"cibhis1ak0002az2fmol9qnz9"},{"name":"iOS","_id":"cibhis1as0009az2fgjx38jc8"}],"Data":[],"Page":[{"title":"About","date":"2015-06-24T14:21:12.000Z","_content":"\n","source":"about/index.md","raw":"title: About\ndate: 2015-06-24 22:21:12\n---\n\n","updated":"2015-06-25T06:35:58.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cibhis1aa0000az2ftle5ijuh"}],"Post":[{"title":"用程序解决数独是一种什么样的体验","date":"2015-06-26T06:54:57.000Z","toc":true,"_content":"\n\n编程是一件很 cool 的事，我一直在寻思着写一点好玩的东西。昨天晚上在 VM 中装好了 ubuntu，玩了几把数独，和机器互虐了几把之后一个问题就来了：用程序解决数独是一种什么样的体验。虽然使用外挂程序破解数独扼杀了数独本身的乐趣，但是我们不妨试一试。这是个算法问题，正好我的 blog 中还没有关于算法的文章，这篇就当是一个开始吧。\n\n![](http://bjcb.morningpost.com.cn/res/1/1/2014-01/23/C08/res03_attpic_brief.jpg)\n\n数独的玩法大家都知道。简单来讲就是 9×9 共 81 个格子，同时组成 9 个九宫格，这些格子里会有若干个（理论上 >= 17 个）提示数。玩家需要在剩余的空格中填入 [1, 9] 区间内的整数，使得数独方阵中每行，每列，每个九宫格中都不出现重复的数字。\n\n<!--more-->\n\n数独的解法在某种意义上可分为两种，一是逻辑解法，就是根据数独中出现的逻辑线索经过运算和推导解题。二是暴力型解法，利用可填数字依次代入破解。这篇文章里，我选择暴力型解法中的`回溯法`编写破解程序，它最简单，但是效率并不算太好。\n\n[回溯法]()也叫试探法，是一种选优搜索法，下面是百科对其的基本思想的描述：\n\n\n> 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n\n不难看出，回溯法的核心思想就是`暂时给定一个符合规则的条件，依照这个条件再在下一级暂时给定一个符合当前规则的条件，如此循环下去，如果途中得到无解结果，则推翻上一级的条件，重新指定另一个条件继续迭代。`下面结合数独具体说明回溯法的解法。\n\n# 建立模型\n\n首先要做的就是用一个数据结构来描述数独，高逼格的说法叫建模。准备这篇文章之前我犹豫了一下 swift 和 C 哪个会更好一点，然而算法无关乎语言，我还是选择了 swift。步入正题，在这个数独方阵中采用二维数组模型可能会更直观一点。我们新建一个`SudokuKiller`类，并定义一个二维数组`tu`表示数独，规定用`0`表示空格。\n\n{% codeblock lang:swift %}\nclass SudokuKiller {\n    var tu: [[Int]] = [[0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n    // 或者\n    // var tu = [[Int]](count: 9, repeatedValue: [Int](count: 9, repeatedValue: 0))\n}\n{% endcodeblock %}\n\n然后声明一个闭包作为回调：\n\n{% codeblock lang:swift %}\n...\nprivate var callback: ((data: [[Int]], finish: Bool) -> Void)?\n{% endcodeblock %}\n\n# 判断合法性\n\n我们需要一个方法来检测填入数字是否符合规则。检测分为两部分，一是行和列，二是就个九宫格。\n\n{% codeblock lang:swift %}\n...\n\n// 指定一个元素，判断该元素是否符合游戏规则\nprivate func isValid(i: Int, _ j: Int) -> Bool {\n    let element = tu[i][j]\n    \n    // 检查该元素所在行和列\n    for tmp in 0..<9 {\n        if (tmp != i && tu[tmp][j] == element) || (tmp != j && tu[i][tmp] == element) {\n            return false\n        }\n    }\n    \n    // 检查该元素所在九宫格\n    let query = [0, 0, 0, 3, 3, 3, 6, 6, 6]\n    for var m = query[i]; m < query[i] + 3; ++m {\n        for var n = query[j]; n < query[j] + 3; ++n {\n            if (m != i || n != j) && tu[m][n] == element {\n                return false\n            }\n        }\n    }\n    \n    return true\n}\n{% endcodeblock %}\n\n\n# 核心算法\n\n我还是觉得代码是最好的说明方式：\n\n{% codeblock lang:swift %}\n...\n\n// 使用回溯算法进行深度优先搜索\nprivate func writeNumberToGrid(grid: Int) {\n    // 如果最后一个格子都填完了，就退出搜索\n    if grid == 81 {\n        // 得到一个解，回调\n        callback!(data: tu, finish: false)\n        return\n    }\n    \n    // 获取行和列\n    let i = grid / 9\n    let j = grid % 9\n    \n    // 如果当前格子不需要填数字（已经有数字存在）就跳到下一个格子\n    if tu[i][j] != 0 {\n        writeNumberToGrid(grid + 1)\n        return\n    }\n    \n    // 尝试 1 - 9 的各种解\n    for num in 1...9 {\n        tu[i][j] = num\n        if isValid(i, j) {\n            // 验证通过，继续下一个格子\n            writeNumberToGrid(grid + 1)\n        }\n    }\n    \n    // 这个时候，如果程序突破了上面各种 if 的重重阻拦运行到这里\n    // 只能说明，擦，这条路走不通，无解。回溯吧。\n    tu[i][j] = 0\n}\n\nfunc kill(done: (data: [[Int]], finish: Bool) -> Void) {\n    callback = done\n    writeNumberToGrid(0)\n    callback!(data: [], finish: true)\n}\n{% endcodeblock %}\n\n\n# 验证\n\n现在来解一解文章开头那张数独。\n\n{% codeblock lang:swift %}\nlet tu = [[0, 0, 0, 0, 0, 0, 6, 0, 0],\n          [2, 3, 0, 0, 0, 0, 0, 0, 0],\n          [0, 0, 0, 0, 0, 0, 9, 0, 0],\n          [0, 0, 6, 0, 0, 7, 0, 0, 0],\n          [5, 0, 0, 2, 0, 0, 0, 3, 0],\n          [0, 0, 0, 0, 0, 0, 0, 1, 0],\n          [0, 0, 7, 0, 6, 9, 0, 0, 0],\n          [0, 1, 0, 0, 0, 0, 0, 2, 5],\n          [0, 0, 0, 0, 0, 8, 0, 0, 0]]\n\nlet s = SudokuKiller()\ns.tu = tu\n\nlet s = SudokuKiller()\ns.tu = tu\n\ns.kill { (data, finish) -> Void in\n    if finish {\n        print(\"Done\")\n        print(\"total time: \\(String(CFAbsoluteTimeGetCurrent() - start))s\")\n    } else {\n        for item in data {\n            print(item)\n        }\n        putchar(10) // 换行\n    }\n}\n{% endcodeblock %}\n\n39 分钟以后，得到所有解，没错，39 分钟，就这一个解：\n\n{% codeblock lang:console %}\n[9, 8, 1, 4, 3, 5, 6, 7, 2]\n[2, 3, 5, 9, 7, 6, 1, 8, 4]\n[7, 6, 4, 8, 1, 2, 9, 5, 3]\n[1, 4, 6, 3, 5, 7, 2, 9, 8]\n[5, 7, 8, 2, 9, 1, 4, 3, 6]\n[3, 9, 2, 6, 8, 4, 5, 1, 7]\n[8, 2, 7, 5, 6, 9, 3, 4, 1]\n[6, 1, 9, 7, 4, 3, 8, 2, 5]\n[4, 5, 3, 1, 2, 8, 7, 6, 9]\n\nDone\ntotal time: 2375.81242704391s\n{% endcodeblock %}\n\n这效率真特么低=͟͟͞͞( •̀д•́)\n\n于是我改写成 C++，28s 后得到了结果，这。。。￣へ￣\n\n{% codeblock lang:console %}\n9 8 1 4 3 5 6 7 2 \n2 3 5 9 7 6 1 8 4 \n7 6 4 8 1 2 9 5 3 \n1 4 6 3 5 7 2 9 8 \n5 7 8 2 9 1 4 3 6 \n3 9 2 6 8 4 5 1 7 \n8 2 7 5 6 9 3 4 1 \n6 1 9 7 4 3 8 2 5 \n4 5 3 1 2 8 7 6 9 \n\nDone\ntotal time: 28.401673s\n{% endcodeblock %}\n\n\n","source":"_posts/用程序解决数独是一种什么样的体验.md","raw":"title: 用程序解决数独是一种什么样的体验\ndate: 2015-06-26 14:54:57\ntoc: true\ncategories:\n- 算法\ntags:\n- 回溯\n- 深度优先\n---\n\n\n编程是一件很 cool 的事，我一直在寻思着写一点好玩的东西。昨天晚上在 VM 中装好了 ubuntu，玩了几把数独，和机器互虐了几把之后一个问题就来了：用程序解决数独是一种什么样的体验。虽然使用外挂程序破解数独扼杀了数独本身的乐趣，但是我们不妨试一试。这是个算法问题，正好我的 blog 中还没有关于算法的文章，这篇就当是一个开始吧。\n\n![](http://bjcb.morningpost.com.cn/res/1/1/2014-01/23/C08/res03_attpic_brief.jpg)\n\n数独的玩法大家都知道。简单来讲就是 9×9 共 81 个格子，同时组成 9 个九宫格，这些格子里会有若干个（理论上 >= 17 个）提示数。玩家需要在剩余的空格中填入 [1, 9] 区间内的整数，使得数独方阵中每行，每列，每个九宫格中都不出现重复的数字。\n\n<!--more-->\n\n数独的解法在某种意义上可分为两种，一是逻辑解法，就是根据数独中出现的逻辑线索经过运算和推导解题。二是暴力型解法，利用可填数字依次代入破解。这篇文章里，我选择暴力型解法中的`回溯法`编写破解程序，它最简单，但是效率并不算太好。\n\n[回溯法]()也叫试探法，是一种选优搜索法，下面是百科对其的基本思想的描述：\n\n\n> 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n\n不难看出，回溯法的核心思想就是`暂时给定一个符合规则的条件，依照这个条件再在下一级暂时给定一个符合当前规则的条件，如此循环下去，如果途中得到无解结果，则推翻上一级的条件，重新指定另一个条件继续迭代。`下面结合数独具体说明回溯法的解法。\n\n# 建立模型\n\n首先要做的就是用一个数据结构来描述数独，高逼格的说法叫建模。准备这篇文章之前我犹豫了一下 swift 和 C 哪个会更好一点，然而算法无关乎语言，我还是选择了 swift。步入正题，在这个数独方阵中采用二维数组模型可能会更直观一点。我们新建一个`SudokuKiller`类，并定义一个二维数组`tu`表示数独，规定用`0`表示空格。\n\n{% codeblock lang:swift %}\nclass SudokuKiller {\n    var tu: [[Int]] = [[0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0]]\n    // 或者\n    // var tu = [[Int]](count: 9, repeatedValue: [Int](count: 9, repeatedValue: 0))\n}\n{% endcodeblock %}\n\n然后声明一个闭包作为回调：\n\n{% codeblock lang:swift %}\n...\nprivate var callback: ((data: [[Int]], finish: Bool) -> Void)?\n{% endcodeblock %}\n\n# 判断合法性\n\n我们需要一个方法来检测填入数字是否符合规则。检测分为两部分，一是行和列，二是就个九宫格。\n\n{% codeblock lang:swift %}\n...\n\n// 指定一个元素，判断该元素是否符合游戏规则\nprivate func isValid(i: Int, _ j: Int) -> Bool {\n    let element = tu[i][j]\n    \n    // 检查该元素所在行和列\n    for tmp in 0..<9 {\n        if (tmp != i && tu[tmp][j] == element) || (tmp != j && tu[i][tmp] == element) {\n            return false\n        }\n    }\n    \n    // 检查该元素所在九宫格\n    let query = [0, 0, 0, 3, 3, 3, 6, 6, 6]\n    for var m = query[i]; m < query[i] + 3; ++m {\n        for var n = query[j]; n < query[j] + 3; ++n {\n            if (m != i || n != j) && tu[m][n] == element {\n                return false\n            }\n        }\n    }\n    \n    return true\n}\n{% endcodeblock %}\n\n\n# 核心算法\n\n我还是觉得代码是最好的说明方式：\n\n{% codeblock lang:swift %}\n...\n\n// 使用回溯算法进行深度优先搜索\nprivate func writeNumberToGrid(grid: Int) {\n    // 如果最后一个格子都填完了，就退出搜索\n    if grid == 81 {\n        // 得到一个解，回调\n        callback!(data: tu, finish: false)\n        return\n    }\n    \n    // 获取行和列\n    let i = grid / 9\n    let j = grid % 9\n    \n    // 如果当前格子不需要填数字（已经有数字存在）就跳到下一个格子\n    if tu[i][j] != 0 {\n        writeNumberToGrid(grid + 1)\n        return\n    }\n    \n    // 尝试 1 - 9 的各种解\n    for num in 1...9 {\n        tu[i][j] = num\n        if isValid(i, j) {\n            // 验证通过，继续下一个格子\n            writeNumberToGrid(grid + 1)\n        }\n    }\n    \n    // 这个时候，如果程序突破了上面各种 if 的重重阻拦运行到这里\n    // 只能说明，擦，这条路走不通，无解。回溯吧。\n    tu[i][j] = 0\n}\n\nfunc kill(done: (data: [[Int]], finish: Bool) -> Void) {\n    callback = done\n    writeNumberToGrid(0)\n    callback!(data: [], finish: true)\n}\n{% endcodeblock %}\n\n\n# 验证\n\n现在来解一解文章开头那张数独。\n\n{% codeblock lang:swift %}\nlet tu = [[0, 0, 0, 0, 0, 0, 6, 0, 0],\n          [2, 3, 0, 0, 0, 0, 0, 0, 0],\n          [0, 0, 0, 0, 0, 0, 9, 0, 0],\n          [0, 0, 6, 0, 0, 7, 0, 0, 0],\n          [5, 0, 0, 2, 0, 0, 0, 3, 0],\n          [0, 0, 0, 0, 0, 0, 0, 1, 0],\n          [0, 0, 7, 0, 6, 9, 0, 0, 0],\n          [0, 1, 0, 0, 0, 0, 0, 2, 5],\n          [0, 0, 0, 0, 0, 8, 0, 0, 0]]\n\nlet s = SudokuKiller()\ns.tu = tu\n\nlet s = SudokuKiller()\ns.tu = tu\n\ns.kill { (data, finish) -> Void in\n    if finish {\n        print(\"Done\")\n        print(\"total time: \\(String(CFAbsoluteTimeGetCurrent() - start))s\")\n    } else {\n        for item in data {\n            print(item)\n        }\n        putchar(10) // 换行\n    }\n}\n{% endcodeblock %}\n\n39 分钟以后，得到所有解，没错，39 分钟，就这一个解：\n\n{% codeblock lang:console %}\n[9, 8, 1, 4, 3, 5, 6, 7, 2]\n[2, 3, 5, 9, 7, 6, 1, 8, 4]\n[7, 6, 4, 8, 1, 2, 9, 5, 3]\n[1, 4, 6, 3, 5, 7, 2, 9, 8]\n[5, 7, 8, 2, 9, 1, 4, 3, 6]\n[3, 9, 2, 6, 8, 4, 5, 1, 7]\n[8, 2, 7, 5, 6, 9, 3, 4, 1]\n[6, 1, 9, 7, 4, 3, 8, 2, 5]\n[4, 5, 3, 1, 2, 8, 7, 6, 9]\n\nDone\ntotal time: 2375.81242704391s\n{% endcodeblock %}\n\n这效率真特么低=͟͟͞͞( •̀д•́)\n\n于是我改写成 C++，28s 后得到了结果，这。。。￣へ￣\n\n{% codeblock lang:console %}\n9 8 1 4 3 5 6 7 2 \n2 3 5 9 7 6 1 8 4 \n7 6 4 8 1 2 9 5 3 \n1 4 6 3 5 7 2 9 8 \n5 7 8 2 9 1 4 3 6 \n3 9 2 6 8 4 5 1 7 \n8 2 7 5 6 9 3 4 1 \n6 1 9 7 4 3 8 2 5 \n4 5 3 1 2 8 7 6 9 \n\nDone\ntotal time: 28.401673s\n{% endcodeblock %}\n\n\n","slug":"用程序解决数独是一种什么样的体验","published":1,"updated":"2015-06-29T06:23:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibhis1af0001az2fe0u2yiux"},{"layout":"photo","title":"手写一枚优雅的拟物风格圆形进度条","date":"2015-06-24T06:33:41.000Z","toc":true,"_content":"\n\n\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","source":"_posts/手写一枚优雅的拟物风格圆形进度条.md","raw":"layout: photo\ntitle: 手写一枚优雅的拟物风格圆形进度条\ndate: 2015-06-24 14:33:41\ntoc: true\ncategories:\n- iOS\ntags: \n- UI\n---\n\n\n\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","slug":"手写一枚优雅的拟物风格圆形进度条","published":1,"updated":"2015-06-25T06:35:58.000Z","comments":1,"photos":[],"link":"","_id":"cibhis1ap0008az2fd5egkjuk"},{"title":"iOS-开发小技巧合集（随时更新）","date":"2015-06-23T11:18:31.000Z","toc":true,"_content":"\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","source":"_posts/iOS-开发小技巧合集（随时更新）.md","raw":"title: iOS-开发小技巧合集（随时更新）\ndate: 2015-06-23 19:18:31\ntoc: true\ncategories:\n- iOS\ntags: \n- App\n---\n\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","slug":"iOS-开发小技巧合集（随时更新）","published":1,"updated":"2015-06-29T02:45:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibhis1cv000daz2fp9fbisdq"},{"title":"CALayer 的 inner shadow","date":"2015-06-24T05:22:09.000Z","toc":false,"_content":"\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","source":"_posts/CALayer-的-inner-shadow.md","raw":"title: CALayer 的 inner shadow\ndate: 2015-06-24 13:22:09\ntoc: false\ncategories:\n- iOS\ntags: \n- UI\n---\n\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","slug":"CALayer-的-inner-shadow","published":1,"updated":"2015-06-25T06:35:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibhis1d1000haz2ff93lvrlw"},{"title":"App 之间的相互跳转","date":"2015-06-23T05:05:02.000Z","_content":"\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","source":"_posts/App-之间的相互跳转.md","raw":"title: App 之间的相互跳转\ndate: 2015-06-23 13:05:02\ncategories:\n- iOS\ntags: \n- App\n---\n\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","slug":"App-之间的相互跳转","published":1,"updated":"2015-06-25T06:35:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cibhis1dq000kaz2fzten2l0n"}],"PostAsset":[{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"1.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"10.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"11.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"12.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"13.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"14.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"15.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","post":"cibhis1ap0008az2fd5egkjuk","slug":"16.gif","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","post":"cibhis1ap0008az2fd5egkjuk","slug":"16.mov","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"16_mov_poster.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"2.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"3.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"4.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"5.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"6.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"7.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"8.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","post":"cibhis1ap0008az2fd5egkjuk","slug":"9.png","modified":1},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）/1.png","post":"cibhis1cv000daz2fp9fbisdq","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"1-1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"2.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"3.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"4.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","post":"cibhis1d1000haz2ff93lvrlw","slug":"5.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/1.png","post":"cibhis1dq000kaz2fzten2l0n","slug":"1.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/2.gif","post":"cibhis1dq000kaz2fzten2l0n","slug":"2.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/3.gif","post":"cibhis1dq000kaz2fzten2l0n","slug":"3.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/4.gif","post":"cibhis1dq000kaz2fzten2l0n","slug":"4.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/5.png","post":"cibhis1dq000kaz2fzten2l0n","slug":"5.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/6.gif","post":"cibhis1dq000kaz2fzten2l0n","slug":"6.gif","modified":1}],"PostCategory":[{"post_id":"cibhis1af0001az2fe0u2yiux","category_id":"cibhis1ak0002az2fmol9qnz9","_id":"cibhis1am0005az2fry809qap"},{"post_id":"cibhis1ap0008az2fd5egkjuk","category_id":"cibhis1as0009az2fgjx38jc8","_id":"cibhis1at000caz2f64p1w78e"},{"post_id":"cibhis1cv000daz2fp9fbisdq","category_id":"cibhis1as0009az2fgjx38jc8","_id":"cibhis1cw000eaz2ft30jh2t4"},{"post_id":"cibhis1d1000haz2ff93lvrlw","category_id":"cibhis1as0009az2fgjx38jc8","_id":"cibhis1d2000iaz2f80m6eg51"},{"post_id":"cibhis1dq000kaz2fzten2l0n","category_id":"cibhis1as0009az2fgjx38jc8","_id":"cibhis1dr000laz2fl3fzoxdo"}],"PostTag":[{"post_id":"cibhis1af0001az2fe0u2yiux","tag_id":"cibhis1ak0003az2feff2ijgw","_id":"cibhis1an0006az2f0uba8emk"},{"post_id":"cibhis1af0001az2fe0u2yiux","tag_id":"cibhis1am0004az2fz2unk0ka","_id":"cibhis1an0007az2fuix9b1c6"},{"post_id":"cibhis1ap0008az2fd5egkjuk","tag_id":"cibhis1at000aaz2fbvanm2kq","_id":"cibhis1at000baz2f8foqsfvl"},{"post_id":"cibhis1cv000daz2fp9fbisdq","tag_id":"cibhis1cw000faz2fkvori7f6","_id":"cibhis1cx000gaz2f7xzc7npl"},{"post_id":"cibhis1d1000haz2ff93lvrlw","tag_id":"cibhis1at000aaz2fbvanm2kq","_id":"cibhis1d3000jaz2foqfipopl"},{"post_id":"cibhis1dq000kaz2fzten2l0n","tag_id":"cibhis1cw000faz2fkvori7f6","_id":"cibhis1dr000maz2fmra3l419"}],"Tag":[{"name":"回溯","_id":"cibhis1ak0003az2feff2ijgw"},{"name":"深度优先","_id":"cibhis1am0004az2fz2unk0ka"},{"name":"UI","_id":"cibhis1at000aaz2fbvanm2kq"},{"name":"App","_id":"cibhis1cw000faz2fkvori7f6"}]}}