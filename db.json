{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/icarus/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/icarus/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/icarus/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/icarus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/icarus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/icarus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/icarus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/icarus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/icarus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/icarus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"6e3b68e6d291c3f84ba6f4a777927feeb1970100","modified":1435214271000},{"_id":"source/_posts/App-之间的相互跳转/5.png","shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转.md","shasum":"62b90f4bed8bea01b774b10f0bbcc15f0c421fe2","modified":1437617700000},{"_id":"source/_posts/Audio-Session-编程指南-一/1.png","shasum":"a4236d4529d36dedec8cbba17e1ec2546bc610a1","modified":1437641736000},{"_id":"source/_posts/Audio-Session-编程指南-一.md","shasum":"a6b712d93f249caef9d810ad4a1442f3d1e350f8","modified":1438232524000},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","shasum":"98f141265aa661071b3c247201b8186fc733c16b","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e","modified":1435214158000},{"_id":"source/_posts/CALayer-的-inner-shadow.md","shasum":"fc327126e407f1145dc706bb99cada84fe915248","modified":1435214158000},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）.md","shasum":"1b1f5ac1e30166267950fdc519a18d4b977a2c78","modified":1435545955000},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）/1.png","shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69","modified":1435214158000},{"_id":"source/marks/index.md","shasum":"bd0848b77b1324348908cce8425d0497922675a9","modified":1438309733000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条.md","shasum":"a69defb57aa279c7484dd91121167db8815cc6b2","modified":1438229844000},{"_id":"source/about/index.md","shasum":"88d01996843e91b5c2fd23cd480b268645b2313e","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/1.png","shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/2.gif","shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9","modified":1435214158000},{"_id":"themes/icarus/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1438220656000},{"_id":"themes/icarus/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1438220656000},{"_id":"themes/icarus/README.md","shasum":"b2fd6c4a5fb5f0094a66a7a4a34a1e4be0b808c0","modified":1438220656000},{"_id":"themes/icarus/_config.yml","shasum":"85d50bf3abc13b1a3af10c38dffac9101be7ab4a","modified":1438233913000},{"_id":"themes/icarus/_source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1438220656000},{"_id":"themes/icarus/_source/categories/index.md","shasum":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1438220656000},{"_id":"themes/icarus/languages/en.yml","shasum":"79d357c2b14b7664982fb23c6832aed69848de05","modified":1438220656000},{"_id":"themes/icarus/languages/id.yml","shasum":"85dcd34cc3963361f0eb5ff27eb23bb003cd0eda","modified":1438220656000},{"_id":"themes/icarus/languages/zh-CN.yml","shasum":"a7b08bbf792d54e167541ba207b43d7e39586a2b","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/after-footer.ejs","shasum":"2adbd282a6d5e47da111d617ba148546fc5d9f4f","modified":1438225591000},{"_id":"themes/icarus/layout/_partial/archive-post.ejs","shasum":"4be85893e8fb09be7e411001d5a14c05b6da475a","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/archive.ejs","shasum":"8a65b701f1af5cd4d98ba48591b4a10c768ac66f","modified":1438225893000},{"_id":"themes/icarus/layout/_partial/article.ejs","shasum":"130bc66150091a73e5310b1bef3b986960b8582b","modified":1438244159000},{"_id":"themes/icarus/layout/_partial/footer.ejs","shasum":"f471f17e2524bfcb37d43d9fc85b5fc247ad08b1","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/head.ejs","shasum":"b0ba23bd5be7794935303740b92a9ff9bbfc58d6","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/header.ejs","shasum":"866431639ed1584b8c9a7deda13c5ec71cb48e5d","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/banner.ejs","shasum":"d67a43264f457c4f914a1e636ebc3e2eaac6fb71","modified":1438225996000},{"_id":"themes/icarus/layout/_partial/post/category.ejs","shasum":"461fa17b3fab1067a7ff8d03130b60403515cf02","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/date.ejs","shasum":"e0e2f5016aa02a6ac7d0b9bca463129b6b86c5f3","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/post/thumbnail.ejs","shasum":"67e249af07eb36088fc37400a58433eb0ff50121","modified":1438226046000},{"_id":"themes/icarus/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1438226097000},{"_id":"themes/icarus/layout/_partial/profile.ejs","shasum":"7d6f56890b852f5fd619e0e31e23c196b13e74bf","modified":1438220656000},{"_id":"themes/icarus/layout/_partial/sidebar.ejs","shasum":"35fbf9cd6d76c49c4f9329bc6e8f9c88703988ec","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/category.ejs","shasum":"5eb356275709ed2cce3bd13cb95743b7ecd4dab1","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/links.ejs","shasum":"5a217756c4175cc74d8b1734883d1c3d6d1c8d7c","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/archive.ejs","shasum":"96321559b5c4e302af3012404537fb95c3a7f3b8","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/recent_posts.ejs","shasum":"942a8ea2ff6284217b14664879cf461515f0e36f","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/tag.ejs","shasum":"9f16e1d97a6908d80aa214a373025cbd03ad7e14","modified":1438220656000},{"_id":"themes/icarus/layout/_widget/tagcloud.ejs","shasum":"bb6d04024fdea842be461e27086c2c138d15de92","modified":1438220656000},{"_id":"themes/icarus/layout/archive.ejs","shasum":"4479c33517aa70f2714ee820775ff8307a0dd115","modified":1438220656000},{"_id":"themes/icarus/layout/categories.ejs","shasum":"db9c4981c8d87e8b08e595a10051f3e13c857cdf","modified":1438220656000},{"_id":"themes/icarus/layout/category.ejs","shasum":"cd17981f9cac718731880148cb17de60d148a75c","modified":1438220656000},{"_id":"themes/icarus/layout/index.ejs","shasum":"505555df272ac4dd23e5eae3acb857a457e421b4","modified":1438220656000},{"_id":"themes/icarus/layout/layout.ejs","shasum":"fc6e16387a9b4bc9532b01380ed669372c1df1ad","modified":1438220656000},{"_id":"themes/icarus/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1438220656000},{"_id":"themes/icarus/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1438220656000},{"_id":"themes/icarus/layout/tag.ejs","shasum":"bcde8c7ce7e21683ca2cba7fcc21ac43c817a9a4","modified":1438220656000},{"_id":"themes/icarus/layout/tags.ejs","shasum":"cf485e9053f96d69a1e0ce0f8a55c3aa33ebde03","modified":1438220656000},{"_id":"themes/icarus/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1438220656000},{"_id":"themes/icarus/package.json","shasum":"a4368eebf2ed07c0aaf9b02d21736da2cef611d4","modified":1438220656000},{"_id":"themes/icarus/source/css/_extend.styl","shasum":"1dad1d157a4d3c4186b27dcfb4549facaebce927","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/archive.styl","shasum":"7e80a60a5fca12be154d3ad77ea5230357412670","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/article.styl","shasum":"1a75202f37d3bf0f36e83b1a57e3c82f0510a5b5","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/comment.styl","shasum":"6846fc40b8cad267b92ceafb1be35c03fde6e494","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/footer.styl","shasum":"a73e33a019b46c46080a66f7ce8e112e8bb32075","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/header.styl","shasum":"73c3f7176d2e838ef767951fc8215689e4297e45","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/highlight.styl","shasum":"19c0c1d8d0287808f8eac8e9c9e6deb43efcfc9e","modified":1438220656000},{"_id":"themes/icarus/source/css/_partial/profile.styl","shasum":"1917670cd1f89260fbb81c8bcc01eb3c54584597","modified":1438228990000},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","shasum":"6dc9095787061c7a3786a9d464b451a0c4ae7475","modified":1438220656000},{"_id":"themes/icarus/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1438220656000},{"_id":"themes/icarus/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1438220656000},{"_id":"themes/icarus/source/css/_variables.styl","shasum":"ffae2b43c0fb48b3a3ca0e2c0cbf4a089356094d","modified":1438220656000},{"_id":"themes/icarus/source/css/images/avatar.png","shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0","modified":1435214158000},{"_id":"themes/icarus/source/css/images/logo.png","shasum":"e606a0584f98268b2fe92303f3254520862ef659","modified":1438220656000},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1438220656000},{"_id":"themes/icarus/source/css/style.styl","shasum":"62add563ec23f75fa7bde0395778bf81cc821d4e","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.css","shasum":"9673e160d32c4811bb7e930ba1e20c36b2997fe1","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1438220656000},{"_id":"themes/icarus/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1438220656000},{"_id":"themes/icarus/source/font-awesome/css/font-awesome.min.css","shasum":"8c15c6bd82c71e9ef1bb11cf24e502fe07518ac5","modified":1438220656000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.eot","shasum":"3e63fc9b3de4580f1f3bec0631436f755b80f167","modified":1438220656000},{"_id":"themes/icarus/source/js/script.js","shasum":"5a9f81308b775d3b5a5e737d1836f61d42661691","modified":1438220656000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"1075231650f579955905bb2f6527148a8e2b4b16","modified":1438220656000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","shasum":"508ec9c8baaa578b42c13176de07218df713cacb","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","shasum":"1413fcc75138333569d37fde946948111244f0a5","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","shasum":"d97b92774d4712472edcde0904c2c492dc5da754","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","shasum":"9695e75f15a94cbed88287d106cba359a8351147","modified":1435214158000},{"_id":"themes/icarus/source/font-awesome/fonts/FontAwesome.otf","shasum":"cde9eb92c8a3ba23d648f76ea3931511f30813f4","modified":1438220656000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"9088143b19979779b2116cef38b661f72d982e19","modified":1438220656000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.woff","shasum":"56ce13e71c2150d81bc972940584915181bd6081","modified":1438220656000},{"_id":"source/_posts/App-之间的相互跳转/3.gif","shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06","modified":1435214158000},{"_id":"source/_posts/App-之间的相互跳转/4.gif","shasum":"451329ec285208e1f9048a8401e0e32a236636f7","modified":1435214158000},{"_id":"themes/icarus/source/font-awesome/fonts/fontawesome-webfont.svg","shasum":"26bb1c5ef100a1cd71923f1d5dc29fc797ef4639","modified":1438220656000},{"_id":"source/_posts/App-之间的相互跳转/6.gif","shasum":"00f0597eabad626b1a515d6d891a0d0201034765","modified":1435214158000},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b","modified":1435214158000},{"_id":"source/_posts/Audio-Session-编程指南-一/2.gif","shasum":"1148a15d565b62d681989ee850f9ef26742c723e","modified":1437646459000},{"_id":"public/js/script.js","modified":1438309745883,"shasum":"5a9f81308b775d3b5a5e737d1836f61d42661691"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff2","modified":1438309745890,"shasum":"1075231650f579955905bb2f6527148a8e2b4b16"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff","modified":1438309745896,"shasum":"56ce13e71c2150d81bc972940584915181bd6081"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.ttf","modified":1438309745900,"shasum":"9088143b19979779b2116cef38b661f72d982e19"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.svg","modified":1438309745908,"shasum":"26bb1c5ef100a1cd71923f1d5dc29fc797ef4639"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.eot","modified":1438309745912,"shasum":"3e63fc9b3de4580f1f3bec0631436f755b80f167"},{"_id":"public/font-awesome/fonts/FontAwesome.otf","modified":1438309745914,"shasum":"cde9eb92c8a3ba23d648f76ea3931511f30813f4"},{"_id":"public/font-awesome/css/font-awesome.min.css","modified":1438309745918,"shasum":"8c15c6bd82c71e9ef1bb11cf24e502fe07518ac5"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1438309745920,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1438309745922,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1438309745924,"shasum":"9673e160d32c4811bb7e930ba1e20c36b2997fe1"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1438309745928,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1438309745931,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1438309745932,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1438309745934,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1438309745935,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1438309745938,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1438309745942,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1438309745944,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1438309745946,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1438309745947,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1438309745950,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1438309745952,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1438309746841,"shasum":"3e127f41006e07bd6c04a3507265e8f1930a1c22"},{"_id":"public/css/images/thumb-default-small.png","modified":1438309747074,"shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba"},{"_id":"public/css/images/logo.png","modified":1438309747077,"shasum":"e606a0584f98268b2fe92303f3254520862ef659"},{"_id":"public/css/images/avatar.png","modified":1438309747079,"shasum":"9e0be3e5e4da48d5eb59896a47d2c6352ddc28f0"},{"_id":"public/CNAME","modified":1438309747080,"shasum":"6e3b68e6d291c3f84ba6f4a777927feeb1970100"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/1.png","modified":1438309747083,"shasum":"f213b127735c4abb5cf3c2533f8f914beb86c3e6"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/10.png","modified":1438309747088,"shasum":"508ec9c8baaa578b42c13176de07218df713cacb"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/11.png","modified":1438309747091,"shasum":"6eaf56d7a86cabeb795ad50d6082f1a94c96795d"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/12.png","modified":1438309747094,"shasum":"1b5b78d363b8d8b6287a8c8553fa9fd2b7b7ecc8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/13.png","modified":1438309747098,"shasum":"1413fcc75138333569d37fde946948111244f0a5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/14.png","modified":1438309747103,"shasum":"d3d15ba45c9a437247f0fc4236327c93a2bcd4b8"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/15.png","modified":1438309747105,"shasum":"b0af8b0334757a54dbc22b881b3d198d765a5661"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.gif","modified":1438309747118,"shasum":"8af6979188b4e1e27d2d86e3474b8a9a271cf24b"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16.mov","modified":1438309747127,"shasum":"51862b5332c2e0b3569873126b1c94edcdd15dd1"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","modified":1438309747129,"shasum":"ccda0550799431c8ccfab18f85116e7d4b5304f5"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/2.png","modified":1438309747133,"shasum":"2b2ad4d7157d547a90fe2dc85101708caaf275ac"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/3.png","modified":1438309747135,"shasum":"e85ee3cd2d39f342b249f3a642715e87c0e43832"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/4.png","modified":1438309747138,"shasum":"c31d974fa1a3d5f5117c93b8cb8b568aaf6a6b69"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/5.png","modified":1438309747141,"shasum":"6fdfa029128f9262d69528894ec7256ffb6cfb52"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/6.png","modified":1438309747144,"shasum":"dc09ad5ecfefc94ff724fa086d58b3baed7de737"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/7.png","modified":1438309747148,"shasum":"c4db0cf7da5d3b49afe63ce7bdb5e2fcbd31816f"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/8.png","modified":1438309747151,"shasum":"d97b92774d4712472edcde0904c2c492dc5da754"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/9.png","modified":1438309747155,"shasum":"9695e75f15a94cbed88287d106cba359a8351147"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（随时更新）/1.png","modified":1438309747159,"shasum":"4f0b6963339d9c6faaa2080bd79b884080e2f740"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1-1.png","modified":1438309747163,"shasum":"98f141265aa661071b3c247201b8186fc733c16b"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/1.png","modified":1438309747168,"shasum":"b653189d10ed0c6f77e893a25e7ac8ba1d6f532d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/2.png","modified":1438309747171,"shasum":"859bbbf30acc33800c9a24bf4cbe74eb823a85ea"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/3.png","modified":1438309747175,"shasum":"b1f8d211ab719bb519e402835cb107b0b9a03069"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/4.png","modified":1438309747178,"shasum":"d8e0235ce9c38bf326f5ea1e70b874a8eff4007d"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/5.png","modified":1438309747181,"shasum":"3aac570b041a79bfb1a517ac72b76d54837d5b5e"},{"_id":"public/2015/07/22/Audio-Session-编程指南-一/1.png","modified":1438309747184,"shasum":"a4236d4529d36dedec8cbba17e1ec2546bc610a1"},{"_id":"public/2015/07/22/Audio-Session-编程指南-一/2.gif","modified":1438309747198,"shasum":"1148a15d565b62d681989ee850f9ef26742c723e"},{"_id":"public/2015/06/23/App-之间的相互跳转/1.png","modified":1438309747206,"shasum":"f25dc710ffcc327ba21eb54bddc72dab8bc9145e"},{"_id":"public/2015/06/23/App-之间的相互跳转/2.gif","modified":1438309747211,"shasum":"68db75d223fa0d6edd8d99f22720127547a63cc9"},{"_id":"public/2015/06/23/App-之间的相互跳转/3.gif","modified":1438309747217,"shasum":"6e90c01333c484b7c21314eac7b9e404bdefcf06"},{"_id":"public/2015/06/23/App-之间的相互跳转/4.gif","modified":1438309747224,"shasum":"451329ec285208e1f9048a8401e0e32a236636f7"},{"_id":"public/2015/06/23/App-之间的相互跳转/5.png","modified":1438309747233,"shasum":"aa6a2e2ebc5fab5ec4a1d37049a6282d077b60d8"},{"_id":"public/2015/06/23/App-之间的相互跳转/6.gif","modified":1438309747241,"shasum":"00f0597eabad626b1a515d6d891a0d0201034765"},{"_id":"public/marks/index.html","modified":1438309747349,"shasum":"8bde1b2a3041ec2d2b904713255d01bb6430ba1e"},{"_id":"public/about/index.html","modified":1438309747364,"shasum":"1fa51376aced161be97ae6895bf55fa405d2e163"},{"_id":"public/2015/07/22/Audio-Session-编程指南-一/index.html","modified":1438309747413,"shasum":"a032c6a7108959403aec0d7343b409848bb23fe9"},{"_id":"public/2015/06/24/手写一枚优雅的拟物风格圆形进度条/index.html","modified":1438309747477,"shasum":"2b8137342e6a517298405f0d6a5684b69e4ead43"},{"_id":"public/2015/06/24/CALayer-的-inner-shadow/index.html","modified":1438309747497,"shasum":"12ac32873381e24067e5657a2917c929bfd227de"},{"_id":"public/2015/06/23/iOS-开发小技巧合集（随时更新）/index.html","modified":1438309747519,"shasum":"70cdcf4be4d75f783ccc150b244b9256b11044af"},{"_id":"public/2015/06/23/App-之间的相互跳转/index.html","modified":1438309747539,"shasum":"fc8de67a88079699ac49ea1d7d24301695147aea"},{"_id":"public/archives/index.html","modified":1438309747561,"shasum":"dce463db6c504ea9878e3b93ee26693277ae540a"},{"_id":"public/archives/2015/index.html","modified":1438309747585,"shasum":"64f72f162a46d62647e0b0a7e9d237d14aac1a30"},{"_id":"public/archives/2015/06/index.html","modified":1438309747603,"shasum":"a8db5eae61997f0effb8ae742e58efd50d915b8a"},{"_id":"public/archives/2015/07/index.html","modified":1438309747611,"shasum":"7c7d8e094c733f9332a8d9b5ee369efbc338f461"},{"_id":"public/categories/iOS/index.html","modified":1438309747635,"shasum":"463f0761f67244f94a37416acc46950322bcc209"},{"_id":"public/index.html","modified":1438309747673,"shasum":"23d38a1e8926cc76eeed6dd948c8d4d0fe048579"},{"_id":"public/tags/UI/index.html","modified":1438309747687,"shasum":"71d592fa96b4cb34b04799b225e6254d80059e52"},{"_id":"public/tags/App/index.html","modified":1438309747702,"shasum":"08d9e28f6e6feb5feb46905401e2496abcc0d3ba"},{"_id":"public/tags/Audio/index.html","modified":1438309747720,"shasum":"7e6b6eb304effe4b6585440d1759a1e1caf6df28"}],"Category":[{"name":"iOS","_id":"cicr0hhqo0003fj1jokrmpvde"}],"Data":[],"Page":[{"toc":true,"_content":"\n这里收集了一些值得收藏的博客，文章或者网站。\n\n\n\n# iOS\n\n## Blog\n\n- [AppCoda](http://www.appcoda.com)\n- [objc中文](http://objcio.cn)\n- [岁寒](http://lvwenhan.com/sort/ios)\n- [码农人生](http://msching.github.io/blog/archives/)\n- [kittenyang](http://kittenyang.com/#blog)\n- [OneV’s Den](http://onevcat.com/#blog)\n- [唐巧的技术博客](http://www.devtang.com/)\n- [J_雨](http://www.jianshu.com/users/8117a2955480/latest_articles)\n- [叶孤城___](http://www.jianshu.com/users/b82d2721ba07/latest_articles)\n\n## Datum","source":"marks/index.md","raw":"toc: true\n\n------\n\n这里收集了一些值得收藏的博客，文章或者网站。\n\n\n\n# iOS\n\n## Blog\n\n- [AppCoda](http://www.appcoda.com)\n- [objc中文](http://objcio.cn)\n- [岁寒](http://lvwenhan.com/sort/ios)\n- [码农人生](http://msching.github.io/blog/archives/)\n- [kittenyang](http://kittenyang.com/#blog)\n- [OneV’s Den](http://onevcat.com/#blog)\n- [唐巧的技术博客](http://www.devtang.com/)\n- [J_雨](http://www.jianshu.com/users/8117a2955480/latest_articles)\n- [叶孤城___](http://www.jianshu.com/users/b82d2721ba07/latest_articles)\n\n## Datum","date":"2015-07-31T02:28:53.000Z","updated":"2015-07-31T02:28:53.000Z","path":"marks/index.html","title":"","comments":1,"layout":"page","_id":"cicr0hhq10000fj1jkrmme30w"},{"title":"About","date":"2015-06-24T14:21:12.000Z","_content":"\n","source":"about/index.md","raw":"title: About\ndate: 2015-06-24 22:21:12\n---\n\n","updated":"2015-06-25T06:35:58.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cicr0hhq70001fj1jxbkskawy"}],"Post":[{"layout":"photo","title":"手写一枚优雅的拟物风格圆形进度条","date":"2015-06-24T06:33:41.000Z","toc":true,"_content":"\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","source":"_posts/手写一枚优雅的拟物风格圆形进度条.md","raw":"layout: photo\ntitle: 手写一枚优雅的拟物风格圆形进度条\ndate: 2015-06-24 14:33:41\ntoc: true\ncategories:\n- iOS\ntags: \n- UI\n---\n\n\n看惯了扁平风格的控件，有点审美疲劳。这篇文章里，我们来用纯代码实现一个优雅的小清新拟物风格圆形进度条。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n\n先来分析一下这个控件，可以看出它有很多层，每个层都有内阴影，外阴影，高光，渐变，以此营造出多层次的立体感。实现这一效果很简单，用 Photoshop 做两张图就可以了。这是实话，但是这里我们不使用任何一张图片（就是要作死）。既然如此，那就必须用纯代码来一点一点的写这个界面了。内阴影可以用直接使用[这篇文章](../CALayer-的-inner-shadow)里的 InnerShadowLayer，外阴影就用 layer 的 shadow 来做，高光和渐变则可以结合 CAGradientLayer 和 InnerShadowLayer 使用。\n\n\n\n# 圆形底盘\n\n这个控件是圆形的，那么我们要做的第一件事情就是创建一个圆。在这之前，先新建一个名为`ElegantProgress`工程，我使用的是 Xcode 7.0 Beta(7A120f) 版以及 lang:swift 2.0。然后把[上一篇文章的源码](https://github.com/zhwayne/InnerShadowLayer)中写过的 `InnerShadowLayer.lang:swift` 和 `UIColor+Hex.lang:swift` 添加进工程\n\n现在开始画圆吧，子类化一个`UIView`取名`ElegantProgressView`。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    }\n}\n{% endcodeblock %}\n\n然后在`ViewController`中实例化一个`ElegantProgressView`对象。\n\n{% codeblock lang:swift %}\nclass ViewController: UIViewController {\n    var progressView: ElegantProgressView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        let bounds = CGRectMake(0, 0, 260, 260)\n        let center = CGPointMake(view.bounds.width / 2, view.bounds.height / 2)\n        progressView = ElegantProgressView(frame: bounds)\n        progressView.center = center\n        \n        self.view.addSubview(progressView)\n    }\n}\n{% endcodeblock %}\n\n![](/{{path}}2.png)\n\n很淡的绿色，有点看不清。不用在意，现在给它加圆角使其成为一个标准的圆，加圆角的操作我们在`ElegantProgressView`的构造方法中实现。\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n}\n{% endcodeblock %}\n\n![](/{{path}}3.png)\n\n圆角有了，然后假设光源在左上方，那么底盘左上角就会有黑色的内阴影，右下角有白色的阴影（参考下面的截面图）。现在我们需要将这两个效果添加进去，这些效果只起到展示作用，所以我们采用添加子 Layer 的方式实现。\n\n![](/{{path}}4.png)\n\n{% codeblock lang:swift %}\noverride init(frame: CGRect) {\n    super.init(frame: frame)\n    self.backgroundColor = UIColor.hexColor(0xeff8f3)\n    \n    /* 添加圆角 */\n    self.layer.masksToBounds = true\n    self.layer.cornerRadius  = self.bounds.width / 2\n    \n    // 添加 layers\n    self.layoutSublayers()\n}\n\nprivate func layoutSublayers() {\n    \n    func addBottom() {  // 给底盘添加黑色和白色的内阴影\n        \n        let topLeftShadowLayer                    = InnerShadowLayer()\n        topLeftShadowLayer.frame                  = CGRectInset(self.bounds, -1.5, -1.5)\n        topLeftShadowLayer.cornerRadius           = topLeftShadowLayer.bounds.width / 2\n        topLeftShadowLayer.innerShadowOpacity     = 0.5\n        topLeftShadowLayer.innerShadowRadius      = 5\n        topLeftShadowLayer.innerShadowOffset      = CGSizeMake(1.6, 1.6)\n        self.layer.addSublayer(topLeftShadowLayer)\n        \n        let bottomRightShadowLayer                = InnerShadowLayer()\n        bottomRightShadowLayer.frame              = CGRectInset(self.bounds, -0.5, -0.5)\n        bottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\n        bottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\n        bottomRightShadowLayer.innerShadowRadius  = 1\n        bottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-0.5, -0.5)\n        self.layer.addSublayer(bottomRightShadowLayer)\n        \n    }\n    addBottom()\n}\n{% endcodeblock %}\n\n\n![](/{{path}}5.png)\n\n# 中间层\n\n底盘的绘制完成了，接下来就要绘制中间的这一层，它不光有内外阴影还有渐变。不要心急，一步一步来 。\n\n首先添加一个层。至于文中出现的颜色，你们找个感觉，哪个合适用哪个。这个层的直径是整个 view 宽度的 90% 左右。\n\n{% codeblock lang:swift %}\n\nprivate func layoutSublayers() {\n    ...\n\n    func addMiddle() {\n        \n        let middleRectInset         = layer.bounds.width * 0.1\n        \n        let middleLayer             = CAShapeLayer()\n        middleLayer.frame           = CGRectInset(layer.bounds, middleRectInset, middleRectInset)\n        middleLayer.cornerRadius    = middleLayer.bounds.width / 2\n        middleLayer.backgroundColor = UIColor.whiteColor().CGColor\n        \n        self.layer.addSublayer(middleLayer)\n        \n    }\n    addMiddle()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}6.png)\n\n然后给他设置外部阴影。在设置 Layer 的外部阴影时最好设置下它的`shouldRasterize`、`contentsScale`和`rasterizationScale`属性以提高渲染性能。\n\n{% codeblock lang:swift %}\n...\n\nmiddleLayer.shouldRasterize    = true\nmiddleLayer.contentsScale      = UIScreen.mainScreen().scale\nmiddleLayer.rasterizationScale = UIScreen.mainScreen().scale\nmiddleLayer.shadowColor        = UIColor.blackColor().CGColor\nmiddleLayer.shadowOffset       = CGSizeMake(2, 6)    // 注意比例\nmiddleLayer.shadowRadius       = 5\nmiddleLayer.shadowOpacity      = 0.3\n\n...\n{% endcodeblock %}\n\n![](/{{path}}7.png)\n\n接着设置渐变图层。\n\n{% codeblock lang:swift %}\n...\n\nlet gradient          = CAGradientLayer()\ngradient.frame        = middleLayer.bounds\ngradient.cornerRadius = gradient.bounds.width / 2\ngradient.colors       = [UIColor.hexColor(0xf8fdfa).CGColor, UIColor.hexColor(0xc1cbc6).CGColor]\ngradient.locations    = [-0.15, 0.75]\ngradient.startPoint   = CGPointMake(0.25, 0)\ngradient.endPoint     = CGPointMake(0.75, 1)\n\nmiddleLayer.addSublayer(gradient)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}8.png)\n\n还有右下角的内阴影，我们直接加在`gradient`上。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = CGRectInset(gradientLayer.bounds, -2, -2)\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-10, -10)\nbottomRightShadowLayer.innerShadowOpacity = 0.3\nbottomRightShadowLayer.innerShadowRadius  = 18\ngradientLayer.masksToBounds               = true\ngradientLayer.addSublayer(bottomRightShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}9.png)\n\n最后加上左上角的高光。\n\n{% codeblock lang:swift %}\n...\n\nlet topLeftShadowLayer               = InnerShadowLayer()\ntopLeftShadowLayer.frame             = CGRectInset(gradientLayer.bounds, -1, -1)\ntopLeftShadowLayer.cornerRadius      = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowColor  = UIColor.whiteColor().CGColor\ntopLeftShadowLayer.innerShadowRadius = 1.5\ntopLeftShadowLayer.innerShadowOffset = CGSizeMake(0.3, 0.9)\ngradientLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}10.png)\n\n# 顶层\n\n接下来部分就是填加一个类似凹陷的层，依然和上面的一样，一点点实现。\n\n最开始，也是加一个圆。调整好大小关系，这个层的直径大概为整个 view 宽度的 50%。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addTop() {\n        \n        let topRectInset  = layer.bounds.width * 0.25\n        \n        let topLayer             = CAShapeLayer()\n        topLayer.frame           = CGRectInset(layer.bounds, topRectInset, topRectInset)\n        topLayer.cornerRadius    = topLayer.bounds.width / 2\n        topLayer.backgroundColor = UIColor.hexColor(0xd5ddd9).CGColor\n        topLayer.masksToBounds   = true;\n        \n        self.layer.addSublayer(topLayer)\n        \n    }\n    addTop()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}11.png)\n\n之后的阴影和高光就一起写了吧。\n\n{% codeblock lang:swift %}\n...\n\nlet bottomRightShadowLayer                = InnerShadowLayer()\nbottomRightShadowLayer.frame              = topLayer.bounds\nbottomRightShadowLayer.cornerRadius       = bottomRightShadowLayer.bounds.width / 2\nbottomRightShadowLayer.innerShadowColor   = UIColor.whiteColor().CGColor\nbottomRightShadowLayer.innerShadowOffset  = CGSizeMake(-1, -1)\nbottomRightShadowLayer.innerShadowRadius  = 2\nbottomRightShadowLayer.innerShadowOpacity = 0.6\n\ntopLayer.addSublayer(bottomRightShadowLayer)\n\n/******************************************************************/\n\nlet topLeftShadowLayer                = InnerShadowLayer()\ntopLeftShadowLayer.frame              = topLayer.bounds\ntopLeftShadowLayer.cornerRadius       = topLeftShadowLayer.bounds.width / 2\ntopLeftShadowLayer.innerShadowRadius  = 15\ntopLeftShadowLayer.innerShadowOpacity = 0.2\ntopLeftShadowLayer.innerShadowOffset  = CGSizeMake(3, 9)\n\ntopLayer.addSublayer(topLeftShadowLayer)\n\n...\n{% endcodeblock %}\n\n![](/{{path}}12.png)\n\n\n# 文字\n\n别忘了提示文字也要加进去。因为文字是会改变的，我们把它作为一个类的成员，方便修改维护。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    private var textLabel: UILabel!\n    ...\n}\n{% endcodeblock %}\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n    \n    func addTextLabel() {\n        \n        let textRectInset  = layer.bounds.width * 0.3\n        let frame          = CGRectInset(self.bounds, textRectInset, textRectInset)\n            \n        textLabel               = UILabel(frame: frame)\n        textLabel.text          = \"Waiting...\"\n        textLabel.font = UIFont(name: \"HelveticaNeue-Thin\", size: 32)\n        textLabel.textColor     = UIColor.hexColor(0x97aea6)\n        textLabel.textAlignment = NSTextAlignment.Center\n            textLabel.adjustsFontSizeToFitWidth = true\n        self.addSubview(textLabel)\n        \n    }\n    addTextLabel()\n    \n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}13.png)\n\n# 进度显示层\n\n界面搭好以后，我们还需要一个进度显示层来实时显示当前进度。这个进度条稍微有一点渐变且依照一个圆形路径运动，我们可以将 mask, gradient 和 path 结合使用达成目的。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    private var progressLayer: CAShapeLayer!\n    ...\n}\n{% endcodeblock %}\n\n现在我们需要做一个渐变层。在这之前先声明一个类属性。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n                \n        let gradientLayer          = CAGradientLayer()\n        gradientLayer.frame        = layer.bounds\n        gradientLayer.cornerRadius = gradientLayer.bounds.width / 2\n        gradientLayer.colors       = [UIColor.hexColor(0x70dc98).CGColor, UIColor.hexColor(0x70dcbf).CGColor]\n        gradientLayer.locations    = [0, 1]\n        gradientLayer.startPoint   = CGPointMake(0.25, 0)\n        gradientLayer.endPoint     = CGPointMake(0.75, 1)\n                \n        layer.addSublayer(gradientLayer)\n                \n    }\n    addProgress()\n\n    ...\n}\n{% endcodeblock %}\n\n![](/{{path}}14.png)\n\n不过仔细想一想，这个层其实应该在最底层。它应该在那个凹下去的槽里才对。把上面的`layer.addSublayer(gradientLayer)`改为`layer.insertSublayer(gradientLayer, atIndex: 0)`吧。\n\n然后画一个合适的路径并把它指定给`progressLayer`，然后把`progressLayer`作为`gradientLayer`的 mask，这样就能够获取一个渐变的遮罩效果。\n\n{% codeblock lang:swift %}\nprivate func layoutSublayers() {\n    ...\n\n    func addProgress() {\n        ...\n\n        let middleRectInset = layer.bounds.width * 0.1\n        let path            = UIBezierPath(arcCenter: layer.position, radius: (layer.bounds.width - middleRectInset) / 2, startAngle: CGFloat(angle: -90), endAngle: CGFloat(angle: 270), clockwise: true).CGPath\n        \n        progressLayer             = CAShapeLayer()\n        progressLayer.frame       = CGRectInset(layer.bounds, layer.borderWidth, layer.borderWidth)\n        progressLayer.fillColor   = UIColor.clearColor().CGColor\n        progressLayer.strokeColor = UIColor.hexColor(0x70dc98).CGColor\n        progressLayer.opacity     = 0.8\n        progressLayer.lineCap     = kCALineCapRound\n        progressLayer.lineWidth   = middleRectInset\n        progressLayer.path        = path\n        progressLayer.strokeEnd   = CGFloat.min\n        \n        gradientLayer.mask = progressLayer\n\n        ...\n    }\n\n    ...\n}\n{% endcodeblock %}\n\n> 注意`progressLayer.strokeEnd = CGFloat.min`这句，其值如果设为 0 就不会显示渐变层了。把它设为 CGFloat.min 是为了能至少显示一个小点出来。\n\n一个销魂的小点出来了。至此，界面部分完结。\n\n![](/{{path}}15.png)\n\n\n# 最后的功能\n\n要实现实时显示进度，需要修改这个控件中**显示进度的层**的状态以及**控件中心的文字**，而`progressLayer`的`strokEnd`属性的取值范围为[0, 1]，可以用来表示 0% - 100%。\n\n我们用一个公开的计算属性间接修改它们。\n\n{% codeblock lang:swift %}\nclass ElegantProgressView: UIView {\n    ...\n    var progress:CGFloat {\n        get { return progressLayer.strokeEnd }\n        set{\n            var realValue = newValue\n            if realValue < CGFloat.min {\n                realValue = CGFloat.min\n            }\n            \n            CATransaction.begin()\n            CATransaction.setDisableActions(false)\n            CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn))\n            CATransaction.setAnimationDuration(0.001)\n            progressLayer.strokeEnd = realValue\n            CATransaction.commit()\n            \n            if realValue <= CGFloat.min {\n                textLabel.text = \"Waiting...\"\n            }\n            else if realValue == 1 {\n                textLabel.text = \"Done\"\n            }\n            else {\n                textLabel.text = NSString(format: \"%.f%%\", realValue * 100) as String\n            }\n        }\n    }\n    ...\n}\n{% endcodeblock %}\n\n\n模拟一下下载进度：\n\n{% codeblock lang:swift %}\ndispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in\n    for i in 0...100 {\n        if i == 0 {\n            NSThread.sleepForTimeInterval(1.5)\n        }\n        else if i < 40 {\n            NSThread.sleepForTimeInterval(0.03)\n        }\n        else if i < 60 {\n            NSThread.sleepForTimeInterval(0.1)\n        }\n        else {\n            NSThread.sleepForTimeInterval(0.01)\n        }\n        let progress = Double(i) / 100.0\n        dispatch_sync(dispatch_get_main_queue(), { () -> Void in\n            self.progressView.progress = CGFloat(progress)\n        })\n    }\n}\n{% endcodeblock %}\n\n\n![](/{{path}}16.gif)\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/ElegantProgress)）\n<div class=\"github-widget\" data-repo=\"zhwayne/ElegantProgress\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n\n\n\n\n\n\n\n\n","slug":"手写一枚优雅的拟物风格圆形进度条","published":1,"updated":"2015-07-30T04:17:24.000Z","comments":1,"photos":[],"link":"","_id":"cicr0hhqh0002fj1jl5m8i0di"},{"title":"iOS-开发小技巧合集（随时更新）","date":"2015-06-23T11:18:31.000Z","toc":true,"_content":"\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","source":"_posts/iOS-开发小技巧合集（随时更新）.md","raw":"title: iOS-开发小技巧合集（随时更新）\ndate: 2015-06-23 19:18:31\ntoc: true\ncategories:\n- iOS\ntags: \n- App\n---\n\n\n总结一些 iOS 开发中常用的技巧和 bug 解决方法。\n\n\n<!--more-->\n\n\n># 如何检测应用更新？\n\n你可以使用友盟等第三方工具，但如果你只想使用轻量级的方法，只需GET这个接口：`http://itunes.apple.com/lookup?id=你的应用程序的ID`，解析返回的json字符串就行。\n\n\n{% blockquote %}\n# 我想完全复制一个 UIView 怎么办，copy 方法好像用不了\n{% endblockquote %}\n\niOS 中并不是所有对象都支持copy，只有遵守NSCopying协议的类才可以发送copy消息，当用你试图使用类似于`UIView *v = [_v1 copy]`方式复制一个UIView时，会抛出一个名为`Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[UIView copyWithZone:]: unrecognized selector sent to instance 0x7ff163d12060'`的异常。这时候我们可以采取使用对象序列化方式复制对象：\n\n{% codeblock lang:objc %}\n\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:_v1];\nUIView *v = [NSKeyedUnarchiver unarchiveObjectWithData:data];\n\n{% endcodeblock %}\n\n\n\n># 如何检测音频蓝牙是否连接\n\n有个小技巧，检测一下当前音频外设是否为 BluetoothA2DPOutput 即可。\n\n{% codeblock lang:objc %}\n\nAVAudioSessionPortDescription *pd = [[AVAudioSession sharedInstance].currentRoute.outputs firstObject];\nif ([pd.portType isEqualToString:@\"BluetoothA2DPOutput\"]) {\n    // TODO:\n}\n\n{% endcodeblock %}\n\n\n\n># 返回高度固定的 tableviewcell (高性能版)\n\n一般我们用来指定 tableviewcell 的高度时使用 `- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath` 方法返回一个固定的高度。但这个方法会被 n 多次调用，其实你只要这么指定下高度就可以 `self.tableView.rowHeight = 100`。\n\n\n\n># 我只是想修改导航栏返回按钮的文字，其他啥都不想干\n\n你可以尝试在 `viewWillDisappear` 方法里这么干：\n\n![](/{{path}}1.png)\n\n\n># 项目中静态库有真机和模拟器两个版本，可不可以合并为一个\n\n在 Xcode 中创建一个静态库文件，编译后会生成两个版本，一个是模拟器版本，一个是真机版本。所以导致后续引入静态库非常不方便，因此很有必要把这两个库打包成一个。合并以后的静态库文件大小是未合并的两个静态库之和。方法如下：\n\n{% codeblock bash %}\n\nlipo -create \"path/to/模拟器专用lib.a\" \"path/to/真机专用lib.a\" -output \"path/to/通用lib.a\"\n\n{% endcodeblock %}\n\n\n\n># 我需要一个完全透明的导航栏\n\nSo easy.\n\n{% codeblock lang:swift %}\n\n/// *** 这两段代码可以把导航栏变透明\nUINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default)\nUINavigationBar.appearance().shadowImage = UIImage()    /// 这个是去除导航栏底部的黑色线条\n\n{% endcodeblock %}\n\n\n># 直接使用 16 进制颜色\n\n使用 16 进制颜色相对麻烦一点，在 objc 中你可以定义这样的宏。在 swift 中建议将它改写成 UIColor 的扩展方法\n\n{% codeblock lang:objc %}\n\n#define UIColorHEX(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]\n\n{% endcodeblock %}\n\n\n># tableviewcell 默认的高亮太丑，如何自定义\n\n{% codeblock lang:swift %}\n\ncell?.selectedBackgroundView = {\n    let view = UIView(frame: cell!.contentView.bounds)\n    view.backgroundColor = UIColor(white: 0.2, alpha: 0.2)\n    return view\n}()\n\n{% endcodeblock %}\n\n\n># 我想让 tableviewcell 的 separator 往左靠近边框，但又不想重写它怎么办\n\n从 iOS 7 开始 tableviewcell 的 separator 遍右移了 27 个像素左右，下面的 3 行代码可以完美解决这个问题。\n\n{% codeblock lang:swift %}\n\ncell?.separatorInset = UIEdgeInsetsZero\ncell?.layoutMargins = UIEdgeInsetsZero\ncell?.preservesSuperviewLayoutMargins = false\n\n{% endcodeblock %}\n\n\n># 如何清空其他应用程序在远程控制界面留下的媒体信息\n\n{% codeblock lang:objc %}\n\n[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\n{% endcodeblock %}\n\n\n\n># push/pop 导航栏时有黑影\n\n应该来说这是 iOS 7 中遗留的一个 bug，直到 8.3 发布也没解决。自己的程序中要修复这个问题也很简单，设置一下试图控制器的背景色就可以。\n\n\n\n># 移除导航栏返回按钮的title\n\n{% codeblock lang:objc %}\n\n[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];\n\n{% endcodeblock %}\n\n\n># 移除subviews\n\n移除 subviews 的常用方法就是遍历 view 中得所有视图依次删除：\n\n{% codeblock lang:objc %}\n\nfor (UIView *items in view.subviews) {\n    [items removeFromSuperview];\n}\n\n{% endcodeblock %}\n\n其实还有一个方法也能快速删除 subviews 而且比 for 循环好看的多：\n\n{% codeblock objc %}\n\n[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];\n\n{% endcodeblock %}\n\n不过这个方法只存在于 objc 中。\n\n\n># Build 版本号自动加1\n\niOS项目开发中有时需要将 build 次数记录下来，在项目的`TARGETS`->`Genneral`中修改相应的 Build 选项即可，但是如果在`Build Phases`中的`Run Script`中新建这样一个脚本就可以在每次 build 时自动把 build 次数加1：\n\n{% codeblock lang:bash %}\n\n#!/bin/bash\nbuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$INFOPLIST_FILE\")\nbuildNumber=$(($buildNumber + 1))\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$INFOPLIST_FILE\"\n\n{% endcodeblock %}\n\n","slug":"iOS-开发小技巧合集（随时更新）","published":1,"updated":"2015-06-29T02:45:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicr0hht60007fj1j4ld6ryhl"},{"title":"CALayer 的 inner shadow","date":"2015-06-24T05:22:09.000Z","toc":false,"_content":"\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","source":"_posts/CALayer-的-inner-shadow.md","raw":"title: CALayer 的 inner shadow\ndate: 2015-06-24 13:22:09\ntoc: false\ncategories:\n- iOS\ntags: \n- UI\n---\n\n我们已经知道，给视图添加阴影效果可以使用 CALayer 对象的 shadowColor、shadowOffset、shadowRadius 和 shadowOpactiy 属性。它们指定了阴影的颜色，方位，模糊度和不透明度。不过这个阴影存在于 layer 外部，而我的需求则是创建一个`具有内阴影的圆`。\n\n![](/{{path}}1.png)\n\n\n<!--more-->\n\n\n画一个圆简单，CALayer 的 cornerRadius 可以为我们指定 layer 的圆角半径。下面的代码为我们创建了一个圆。\n\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n![](/{{path}}1-1.png)\n\n`hexColor`是我实现的一个 UIColor 扩展：\n\n{% codeblock lang:swift %}\nextension UIColor {\n    class func hexColor(color: Int) -> UIColor {\n        let r = (CGFloat)((color & 0xFF0000) >> 16) / 255.0\n        let g = (CGFloat)((color & 0xFF00) >> 8) / 255.0\n        let b = (CGFloat)(color & 0xFF) / 255.0\n        return UIColor(red: r, green: g, blue: b, alpha: 1)\n    }\n}\n{% endcodeblock %}\n\n但这个内阴影让人有点头疼，因为 Core Animation 并没有为我们提供任何可行的 API 去直接设置 layer 的 inner shadow，所以只能自己实现相关操作。最开始的想法是建立一个长度为圆周长的 CAGradientLayer，设置它的渐变色（从 blackColor 到 clearColor），然后把它弯曲变形成一个圆。\n\n![](/{{path}}2.png)\n\n不过，这个把简单的问题复杂化了，除了涉及渐变还要考虑图形变形。那 Core Graphics 画图呢？我们是可以直接在 layer 上绘制图形的。于是上 stackoverflow 搜寻相关问题，庆幸的是，[这个问题](https://stackoverflow.com/questions/18671355/how-to-create-rounded-uitextfield-with-inner-shadow)给了我解决方案。\n\n由于 layer 只负责显示和动画，并不处理交互事件，而阴影只是单纯地作为装饰显示在视图中，那我们把 shadow 单独作为一个图层覆盖在需要 inner shadow 的视图上，这个 inner shadow 尺寸需要足够大，能够满足 offset 的正常需求（模拟光源位置不同产生的投影角度也不同），并且最重要的是它必须是中间镂空的，也就是说这个 inner shadow 其实是一个遮罩层。\n\n现在子类化一个 CALayer，命名为 InnerShadowLayer，在 InnerShadowLayer 的`drawInContext`方法中设置阴影路径。另外，我们还需要 4 个属性记录和监听阴影信息，比如阴影颜色，方位，不透明度和模糊度。\n\n\n{% codeblock lang:swift linenos%}\nimport UIKit\n\nclass InnerShadowLayer: CALayer {\n    var innerShadowColor: CGColor? = UIColor.blackColor().CGColor {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOffset: CGSize = CGSizeMake(0, 0) {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowRadius: CGFloat = 8 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    var innerShadowOpacity: Float = 1 {\n        didSet {\n            setNeedsDisplay()\n        }\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    override init() {\n        super.init()\n        \n        self.masksToBounds      = true\n        self.shouldRasterize    = true\n        self.contentsScale      = UIScreen.mainScreen().scale\n        self.rasterizationScale = UIScreen.mainScreen().scale\n        \n        setNeedsDisplay()\n    }\n    \n    override func drawInContext(ctx: CGContext) {\n        print(\"draw\")\n        // 设置 Context 属性\n        // 允许抗锯齿\n        CGContextSetAllowsAntialiasing(ctx, true);\n        // 允许平滑\n        CGContextSetShouldAntialias(ctx, true);\n        // 设置插值质量\n        CGContextSetInterpolationQuality(ctx, kCGInterpolationHigh);\n        \n        // 以下为核心代码\n        \n        // 创建 color space\n        let colorspace = CGColorSpaceCreateDeviceRGB();\n        \n        var rect   = self.bounds\n        var radius = self.cornerRadius\n        \n        // 去除边框的大小\n        if self.borderWidth != 0 {\n            rect   = CGRectInset(rect, self.borderWidth, self.borderWidth);\n            radius -= self.borderWidth\n            radius = max(radius, 0)\n        }\n        \n        // 创建 inner shadow 的镂空路径\n        let someInnerPath: CGPathRef = UIBezierPath(roundedRect: rect, cornerRadius: radius).CGPath\n        CGContextAddPath(ctx, someInnerPath)\n        CGContextClip(ctx)\n        \n        // 创建阴影填充区域，并镂空中心\n        let shadowPath = CGPathCreateMutable()\n        let shadowRect = CGRectInset(rect, -rect.size.width, -rect.size.width)\n        CGPathAddRect(shadowPath, nil, shadowRect)\n        CGPathAddPath(shadowPath, nil, someInnerPath);\n        CGPathCloseSubpath(shadowPath)\n        \n        // 获取填充颜色信息\n        let oldComponents: UnsafePointer<CGFloat> = CGColorGetComponents(self.innerShadowColor)\n        var newComponents:[CGFloat] = [0, 0, 0, 0]\n        let numberOfComponents: Int = CGColorGetNumberOfComponents(self.innerShadowColor);\n        switch (numberOfComponents){\n        case 2:\n            // 灰度\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[0]\n            newComponents[2] = oldComponents[0]\n            newComponents[3] = oldComponents[1] * CGFloat(self.innerShadowOpacity)\n        case 4:\n            // RGBA\n            newComponents[0] = oldComponents[0]\n            newComponents[1] = oldComponents[1]\n            newComponents[2] = oldComponents[2]\n            newComponents[3] = oldComponents[3] * CGFloat(self.innerShadowOpacity)\n        default: break\n        }\n        \n        // 根据颜色信息创建填充色\n        let innerShadowColorWithMultipliedAlpha = CGColorCreate(colorspace, newComponents)\n        \n        // 填充阴影\n        CGContextSetFillColorWithColor(ctx, innerShadowColorWithMultipliedAlpha)\n        CGContextSetShadowWithColor(ctx, self.innerShadowOffset, self.innerShadowRadius, innerShadowColorWithMultipliedAlpha)\n        CGContextAddPath(ctx, shadowPath)\n        CGContextEOFillPath(ctx)\n    }\n}\n{% endcodeblock %}\n\n这时我们可以使用这个 InnerShadowLayer 了:\n\n{% codeblock lang:swift linenos%}\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    \n    let myView                      = UIView(frame: CGRectMake(0, 0, 280, 280))\n    myView.layer.backgroundColor    = UIColor.hexColor(0xeeeeee).CGColor\n    myView.center                   = self.view.center\n    myView.layer.cornerRadius       = myView.bounds.size.width / 2\n    myView.layer.shouldRasterize    = true\n    myView.layer.contentsScale      = UIScreen.mainScreen().scale\n    myView.layer.rasterizationScale = UIScreen.mainScreen().scale\n    \n    let shadowLayer          = InnerShadowLayer()\n    shadowLayer.frame        = myView.bounds\n    shadowLayer.cornerRadius = myView.layer.cornerRadius\n    myView.layer.addSublayer(shadowLayer)\n    \n    self.view.addSubview(myView)\n}\n{% endcodeblock %}\n\n效果大致就出来了：\n\n![](/{{path}}3.png)\n\n现在还有一个问题，这个阴影不太明显，我需要的阴影左上角黑色再多一点，颜色再深一点，右下角阴影很少（就是本文最上面的图右边一个），这样立体感很强。而我们只需要适当修改那 4 个属性就成实现。\n\n{% codeblock lang:swift %}\nshadowLayer.innerShadowOffset  = CGSizeMake(4, 4)\nshadowLayer.innerShadowOpacity = 0.4\nshadowLayer.innerShadowRadius  = 16\n{% endcodeblock %}\n\n最终结果(左图)和外阴影的效果对比：\n\n![](/{{path}}4.png) ![](/{{path}}5.png)\n\n\n---\n\n完整工程示例：⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇ （若无法显示请刷新或者点击[这里](http://github.com/zhwayne/InnerShadowLayer)）\n\n<div class=\"github-widget\" data-repo=\"zhwayne/InnerShadowLayer\"></div>\n<script src=\"/js/jquery-2.0.3.min.js\"></script>\n<script src=\"/js/jquery.githubRepoWidget.min.js\"></script>\n","slug":"CALayer-的-inner-shadow","published":1,"updated":"2015-06-25T06:35:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicr0hhte000bfj1j4lpphoqc"},{"title":"Audio Session 编程指南(一)","date":"2015-07-22T05:17:37.000Z","_content":"\n\niOS为我们的 APP 提供了一系列的方式去播放音频，常见的音频相关框架有 AVPlayer，AVAudioPlayer，AVAudioRecorder，AudioQueue 以及 Audio Unit。另外还有一个和音视频联系非常紧密的一个东西，就是 Audio Session。这个类本身并不参与控制音频的播放，它作为 iOS 设备播放音频策略的一个辅助工具并提供了以下几个主要功能：\n\n- 决定 APP 的音频共存行为\n- 选择合适的音频设备\n- 音频的中断处理\n\n\n\n什么是“APP 的音频共存行为”？你应该注意到，当你在用网易云音乐播放一首喜欢的歌，然后进入酷狗查看最新的华语排行榜时，正在播放的歌曲自动暂停了。于是曰：“网易云和酷狗的音乐不能共存。”共存即同时播放，一般情况下你见不到两个同时播放不同音乐的 APP，同时播放两首歌不是很反人类么？\n\n<!--more-->\n\niOS 系统如何处理具有竞争性的音频需求？\n\niOS 为每一个应用程序提供了一个 Audio Session，每个 Audio Session 单独参与各自 APP 的辅助管理。虽然我们一般用 `[AVAudioSession sharedInstance]`获取一个音频会话单例，这个单例\b只存在于我们创建的 APP 中。你可以试着创建两个 APP，在下面的方法中展示各自获取到的 Session，不难看出它们是两个不同的实例。\n\n``` objc\n- (void)applicationDidBecomeActive:(UIApplication *)application {\n    NSString *message = [NSString stringWithFormat:@\"%@\", [AVAudioSession sharedInstance]];\n    UIAlertView *a = [[UIAlertView alloc] initWithTitle:nil\n                                                message:message\n                                               delegate:nil\n                                      cancelButtonTitle:@\"OK\"\n                                      otherButtonTitles:nil, nil];\n    [a show];\n}\n```\n\n应用程序在启动时，iOS 为其提供一个应用内的全局 Session，在默认情况下，系统会自动激活这个 Session，但是苹果推荐我们明确显式地激活它。\n\n    NSError *activationError = nil;\n    BOOL success = [[AVAudioSession sharedInstance] setActive: YES error:&activationError];\n    if (!success) { /* handle the error in activationError */ }\n\n为什么需要激活？\n\n假设我正在用网易云音乐听《New Soul》这首歌，然后我切换到酷狗去听《Five Hundred Miles》。这时候酷狗需要向系统请求播放音频，而此时网易云正在欢乐地唱着歌，于是系统的 Core Audio 服务会暂停网易云的音频播放，让酷狗能安静深情地演唱。激活的目的就在于此，禁用其他 APP 的 Audio Session 以使自身的 Audio Session 处于活跃状态。[苹果官方文档](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/ConfiguringanAudioSession/ConfiguringanAudioSession.html#//apple_ref/doc/uid/TP40007875-CH2-SW7)用了一个飞机场的例子形象地说明了这个问题。\n\n![](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Art/competing_audio_demands_2x.png)\n\n\n\n我就是想同时播放两首歌怎么办？！\n\n你要是这么任性也没关系，要实现这个需求就必须再说说 Audio Session 的 Category。Category 是一个为你的 APP 定义了一套音频行为的 key，设置不同的 Category，APP 表现出来的音频行为也就不一样。具体来说，Category 有以下几个：\n\n| Categories                            | Description                                                                                                                                             | \n| :------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------ | \n| AVAudioSessionCategoryAmbient         | 只用于音频播放。<br/>特点是允许其他应用程序播放音频，当 Audio Session 的 Active 设为 NO 时（即不激活 Session），你应该会听到两个 APP 同时播放声音。<br/>注意，使用该 Category 的 APP 的音频会随着屏幕关闭、进入后台和开启静音键而中断。    | \n| AVAudioSessionCategorySoloAmbient     | Audio Session 默认的 Category，只用于音频播放。<br/>当 Category 设置为它时，不管 Session 是否被激活，其他 APP 的音频都会被中断（不允许音频共存）。<br/>注意，使用该 Category 的 APP 的音频会随着屏幕关闭、进入后台和开启静音键而中断。 | \n| AVAudioSessionCategoryPlayback        | 只用于音频播放。<br/>不允许音频共存。<br/>允许后台播放，且忽略静音键作用。<br/>注意，为了支持后台播放，你需要在应用程序的 info.plist 文件中正确设置 Required background modes。                                      | \n| AVAudioSessionCategoryRecord          | 只用于音频录制。<br/>设置该 Category 后，除了来电铃声，闹钟或日历提醒之外的其它系统声音都不会被播放。该 Category 只提供单纯录音功能。                                                                         | \n| AVAudioSessionCategoryPlayAndRecord   | 用于音频播放和录制。<br/>用于既需要播放声音又需要录音的应用，语音聊天应用（如微信）应该使用这个Category。如果你的应用需要用到 iPhone 上的听筒，该 Category是你唯一的选择，在该 Category 下声音的默认出口为听筒（在没有外接设备的情况下）。               | \n| AVAudioSessionCategoryAudioProcessing | 只用于离线音频处理，即使用硬件编解码器处理音频，如离线音频格式转换。<br/>该音频会话使用期间，不能播放和录制音频。<br/>不过实测中并没有什么卵用，音频还是正常播，How?😧                                                             | \n| AVAudioSessionCategoryMultiRoute      | 用于音频播放和录制。<br/>它允许多个音频输入/输出，比如音频数据同时从耳机和 USB 接口中出来。好像也不怎么常用。                                                                                            | \n\n看看，为了能够与其他音频共存，我们只能选`AVAudioSessionCategoryAmbient`这个。先来创建第一个 APP，它只负责播放一段音乐，支持后台，那么它的 Audio Session Category 可以指定为`AVAudioSessionCategoryPlayback`。\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSError *error = nil;\n    [[AVAudioSession sharedInstance] setActive:YES error:&error];\n    if (error) {\n        NSLog(@\"Get an active error: %@\", error.description);\n        return;\n    }\n\n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&error];\n    if (error) {\n        NSLog(@\"Get a category error: %@\", error.description);\n        return;\n    }\n\n    self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[[NSBundle mainBundle] URLForResource:@\"1\" withExtension:@\"mp3\"] error:nil];\n    [self.player play];\n}\n```\n\n在 info.plist 文件中设置`Required background modes`为`App plays audio or streams audio/video using AirPlay`避免程序进入后台后音乐中断。\n\n运行它，美妙音乐响起，然后在音乐声中创建第二个 APP。\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSError *error = nil;\n    // 注意设置为 NO，强制不激活。\n    [[AVAudioSession sharedInstance] setActive:NO error:&error];\n    if (error) {\n        NSLog(@\"Get an active error: %@\", error.description);\n        return;\n    }\n\n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:&error];\n    if (error) {\n        NSLog(@\"Get a category error: %@\", error.description);\n        return;\n    }\n\n    self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[[NSBundle mainBundle] URLForResource:@\"2\" withExtension:@\"mp3\"] error:nil];\n    [self.player play];\n}\n```\n\n运行以后，就能听见两首歌在群魔乱舞了。\n\nAPP 的音频共存行为先说到这里，本文并不作为官方文档的中文翻译，详细技术还需查阅[原文](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionBasics/AudioSessionBasics.html#//apple_ref/doc/uid/TP40007875-CH3-SW1)。\n\n补充：\n\n如何优雅的请求录音权限？\n\n从 iOS 7 开始，我们的 APP 需要录音必须获得用户的授权。如果程序中开始了录音，系统会自动提示用户是否需要授权。\n\n![](/{{path}}1.png)\n\n出现这个提示后，录音会被暂时阻塞，直到用户确认授权。如果点击了不允许，以后只能在设置里重新手动授权。这样用户没有一点心里准备，你应该在授权之前告知用户授权的目的，很显然我们不能修改系统的这个提示框，我们需要自己掌控系统何时会弹出这个授权提示框，用`requestRecordPermission:`方法可以帮我们实现，这里有一个很简单的 Demo。\n\n``` objc\n#import \"ViewController.h\"\n#import <AVFoundation/AVFoundation.h>\n\n@protocol AVAudioSessionRequestRecordPermissionDelegate <NSObject>\n\n@required\n- (void)didRequestedRecordPermission:(BOOL)result;\n\n@end\n\n@interface ViewController ()\n<\nUIAlertViewDelegate,\nAVAudioSessionRequestRecordPermissionDelegate\n>\n\n@property (nonatomic, strong) AVAudioRecorder *recorder;\n@property (nonatomic, weak) id<AVAudioSessionRequestRecordPermissionDelegate> permissionDelegate;\n\n@end\n\n@implementation ViewController\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.permissionDelegate = self;\n    \n    @try {\n        [self configAudioSession];\n        [self requestRecordPermission];\n    }\n    @catch (NSException *exception) {\n        NSLog(@\"%@\", exception.name);\n    }\n}\n\n- (void)configAudioSession\n{\n    NSError *error = nil;\n    [[AVAudioSession sharedInstance] setActive:YES\n                                         error:&error];\n    if (error) {\n        @throw [NSException exceptionWithName:@\"Active error\"\n                                       reason:error.description\n                                     userInfo:nil];\n    }\n    \n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord\n                                           error:&error];\n    if (error) {\n        @throw [NSException exceptionWithName:@\"Category error\"\n                                       reason:error.description\n                                     userInfo:nil];\n    }\n}\n\n- (void)requestRecordPermission\n{\n    switch ([AVAudioSession sharedInstance].recordPermission) {\n        case AVAudioSessionRecordPermissionUndetermined: {\n            // 第一次运行 APP，待定状态\n            UIAlertView *a = [[UIAlertView alloc] initWithTitle:@\"授权提示\"\n                                                        message:@\"你需要授权该 APP 获取音频权限才能录音。\"\n                                                       delegate:self\n                                              cancelButtonTitle:@\"好的，我知道了\"\n                                              otherButtonTitles:nil, nil];\n            [a show];\n            break;\n        }\n\n        case AVAudioSessionRecordPermissionDenied:\n            // 被拒绝过了\n            [self.permissionDelegate didRequestedRecordPermission:NO];\n            break;\n            \n        case AVAudioSessionRecordPermissionGranted: {\n            // 已经被允许\n            [self.permissionDelegate didRequestedRecordPermission:YES];\n            break;\n        }\n            \n        default:\n            break;\n    }\n}\n\n- (void)startRecord\n{\n    self.recorder = [[AVAudioRecorder alloc] initWithURL:[NSURL fileURLWithPath:NSHomeDirectory()]\n                                                settings:nil\n                                                   error:nil];\n    [self.recorder record];\n}\n\n#pragma mark - UIAlertViewDelegate\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    [[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) {\n        [self.permissionDelegate didRequestedRecordPermission:granted];\n    }];\n}\n\n#pragma mark - AVAudioSessionRequestRecordPermissionDelegate\n- (void)didRequestedRecordPermission:(BOOL)result\n{\n    if (result) {\n        // Granted\n        NSLog(@\"Granted\");\n        [self startRecord];\n    }\n    else {\n        // Denied\n        NSLog(@\"Denied\");\n        UIAlertView *a = [[UIAlertView alloc] initWithTitle:nil\n                                                    message:@\"没有录音权限，去设置里开启。\"\n                                                   delegate:nil\n                                          cancelButtonTitle:@\"取消\"\n                                          otherButtonTitles: nil, nil];\n        [a show];   // 这个提示框可能要等几秒钟才出来，原因不详。\n    }\n}\n\n@end\n```\n\n\n\n![](/{{path}}2.gif)","source":"_posts/Audio-Session-编程指南-一.md","raw":"title: Audio Session 编程指南(一)\n\ndate: 2015-07-22 13:17:37\n\ncategories:\n\n- iOS\n\ntags:\n\n- Audio\n\n------\n\n\niOS为我们的 APP 提供了一系列的方式去播放音频，常见的音频相关框架有 AVPlayer，AVAudioPlayer，AVAudioRecorder，AudioQueue 以及 Audio Unit。另外还有一个和音视频联系非常紧密的一个东西，就是 Audio Session。这个类本身并不参与控制音频的播放，它作为 iOS 设备播放音频策略的一个辅助工具并提供了以下几个主要功能：\n\n- 决定 APP 的音频共存行为\n- 选择合适的音频设备\n- 音频的中断处理\n\n\n\n什么是“APP 的音频共存行为”？你应该注意到，当你在用网易云音乐播放一首喜欢的歌，然后进入酷狗查看最新的华语排行榜时，正在播放的歌曲自动暂停了。于是曰：“网易云和酷狗的音乐不能共存。”共存即同时播放，一般情况下你见不到两个同时播放不同音乐的 APP，同时播放两首歌不是很反人类么？\n\n<!--more-->\n\niOS 系统如何处理具有竞争性的音频需求？\n\niOS 为每一个应用程序提供了一个 Audio Session，每个 Audio Session 单独参与各自 APP 的辅助管理。虽然我们一般用 `[AVAudioSession sharedInstance]`获取一个音频会话单例，这个单例\b只存在于我们创建的 APP 中。你可以试着创建两个 APP，在下面的方法中展示各自获取到的 Session，不难看出它们是两个不同的实例。\n\n``` objc\n- (void)applicationDidBecomeActive:(UIApplication *)application {\n    NSString *message = [NSString stringWithFormat:@\"%@\", [AVAudioSession sharedInstance]];\n    UIAlertView *a = [[UIAlertView alloc] initWithTitle:nil\n                                                message:message\n                                               delegate:nil\n                                      cancelButtonTitle:@\"OK\"\n                                      otherButtonTitles:nil, nil];\n    [a show];\n}\n```\n\n应用程序在启动时，iOS 为其提供一个应用内的全局 Session，在默认情况下，系统会自动激活这个 Session，但是苹果推荐我们明确显式地激活它。\n\n    NSError *activationError = nil;\n    BOOL success = [[AVAudioSession sharedInstance] setActive: YES error:&activationError];\n    if (!success) { /* handle the error in activationError */ }\n\n为什么需要激活？\n\n假设我正在用网易云音乐听《New Soul》这首歌，然后我切换到酷狗去听《Five Hundred Miles》。这时候酷狗需要向系统请求播放音频，而此时网易云正在欢乐地唱着歌，于是系统的 Core Audio 服务会暂停网易云的音频播放，让酷狗能安静深情地演唱。激活的目的就在于此，禁用其他 APP 的 Audio Session 以使自身的 Audio Session 处于活跃状态。[苹果官方文档](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/ConfiguringanAudioSession/ConfiguringanAudioSession.html#//apple_ref/doc/uid/TP40007875-CH2-SW7)用了一个飞机场的例子形象地说明了这个问题。\n\n![](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Art/competing_audio_demands_2x.png)\n\n\n\n我就是想同时播放两首歌怎么办？！\n\n你要是这么任性也没关系，要实现这个需求就必须再说说 Audio Session 的 Category。Category 是一个为你的 APP 定义了一套音频行为的 key，设置不同的 Category，APP 表现出来的音频行为也就不一样。具体来说，Category 有以下几个：\n\n| Categories                            | Description                                                                                                                                             | \n| :------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------ | \n| AVAudioSessionCategoryAmbient         | 只用于音频播放。<br/>特点是允许其他应用程序播放音频，当 Audio Session 的 Active 设为 NO 时（即不激活 Session），你应该会听到两个 APP 同时播放声音。<br/>注意，使用该 Category 的 APP 的音频会随着屏幕关闭、进入后台和开启静音键而中断。    | \n| AVAudioSessionCategorySoloAmbient     | Audio Session 默认的 Category，只用于音频播放。<br/>当 Category 设置为它时，不管 Session 是否被激活，其他 APP 的音频都会被中断（不允许音频共存）。<br/>注意，使用该 Category 的 APP 的音频会随着屏幕关闭、进入后台和开启静音键而中断。 | \n| AVAudioSessionCategoryPlayback        | 只用于音频播放。<br/>不允许音频共存。<br/>允许后台播放，且忽略静音键作用。<br/>注意，为了支持后台播放，你需要在应用程序的 info.plist 文件中正确设置 Required background modes。                                      | \n| AVAudioSessionCategoryRecord          | 只用于音频录制。<br/>设置该 Category 后，除了来电铃声，闹钟或日历提醒之外的其它系统声音都不会被播放。该 Category 只提供单纯录音功能。                                                                         | \n| AVAudioSessionCategoryPlayAndRecord   | 用于音频播放和录制。<br/>用于既需要播放声音又需要录音的应用，语音聊天应用（如微信）应该使用这个Category。如果你的应用需要用到 iPhone 上的听筒，该 Category是你唯一的选择，在该 Category 下声音的默认出口为听筒（在没有外接设备的情况下）。               | \n| AVAudioSessionCategoryAudioProcessing | 只用于离线音频处理，即使用硬件编解码器处理音频，如离线音频格式转换。<br/>该音频会话使用期间，不能播放和录制音频。<br/>不过实测中并没有什么卵用，音频还是正常播，How?😧                                                             | \n| AVAudioSessionCategoryMultiRoute      | 用于音频播放和录制。<br/>它允许多个音频输入/输出，比如音频数据同时从耳机和 USB 接口中出来。好像也不怎么常用。                                                                                            | \n\n看看，为了能够与其他音频共存，我们只能选`AVAudioSessionCategoryAmbient`这个。先来创建第一个 APP，它只负责播放一段音乐，支持后台，那么它的 Audio Session Category 可以指定为`AVAudioSessionCategoryPlayback`。\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSError *error = nil;\n    [[AVAudioSession sharedInstance] setActive:YES error:&error];\n    if (error) {\n        NSLog(@\"Get an active error: %@\", error.description);\n        return;\n    }\n\n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&error];\n    if (error) {\n        NSLog(@\"Get a category error: %@\", error.description);\n        return;\n    }\n\n    self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[[NSBundle mainBundle] URLForResource:@\"1\" withExtension:@\"mp3\"] error:nil];\n    [self.player play];\n}\n```\n\n在 info.plist 文件中设置`Required background modes`为`App plays audio or streams audio/video using AirPlay`避免程序进入后台后音乐中断。\n\n运行它，美妙音乐响起，然后在音乐声中创建第二个 APP。\n\n``` objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    NSError *error = nil;\n    // 注意设置为 NO，强制不激活。\n    [[AVAudioSession sharedInstance] setActive:NO error:&error];\n    if (error) {\n        NSLog(@\"Get an active error: %@\", error.description);\n        return;\n    }\n\n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:&error];\n    if (error) {\n        NSLog(@\"Get a category error: %@\", error.description);\n        return;\n    }\n\n    self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:[[NSBundle mainBundle] URLForResource:@\"2\" withExtension:@\"mp3\"] error:nil];\n    [self.player play];\n}\n```\n\n运行以后，就能听见两首歌在群魔乱舞了。\n\nAPP 的音频共存行为先说到这里，本文并不作为官方文档的中文翻译，详细技术还需查阅[原文](https://developer.apple.com/library/prerelease/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionBasics/AudioSessionBasics.html#//apple_ref/doc/uid/TP40007875-CH3-SW1)。\n\n补充：\n\n如何优雅的请求录音权限？\n\n从 iOS 7 开始，我们的 APP 需要录音必须获得用户的授权。如果程序中开始了录音，系统会自动提示用户是否需要授权。\n\n![](/{{path}}1.png)\n\n出现这个提示后，录音会被暂时阻塞，直到用户确认授权。如果点击了不允许，以后只能在设置里重新手动授权。这样用户没有一点心里准备，你应该在授权之前告知用户授权的目的，很显然我们不能修改系统的这个提示框，我们需要自己掌控系统何时会弹出这个授权提示框，用`requestRecordPermission:`方法可以帮我们实现，这里有一个很简单的 Demo。\n\n``` objc\n#import \"ViewController.h\"\n#import <AVFoundation/AVFoundation.h>\n\n@protocol AVAudioSessionRequestRecordPermissionDelegate <NSObject>\n\n@required\n- (void)didRequestedRecordPermission:(BOOL)result;\n\n@end\n\n@interface ViewController ()\n<\nUIAlertViewDelegate,\nAVAudioSessionRequestRecordPermissionDelegate\n>\n\n@property (nonatomic, strong) AVAudioRecorder *recorder;\n@property (nonatomic, weak) id<AVAudioSessionRequestRecordPermissionDelegate> permissionDelegate;\n\n@end\n\n@implementation ViewController\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.permissionDelegate = self;\n    \n    @try {\n        [self configAudioSession];\n        [self requestRecordPermission];\n    }\n    @catch (NSException *exception) {\n        NSLog(@\"%@\", exception.name);\n    }\n}\n\n- (void)configAudioSession\n{\n    NSError *error = nil;\n    [[AVAudioSession sharedInstance] setActive:YES\n                                         error:&error];\n    if (error) {\n        @throw [NSException exceptionWithName:@\"Active error\"\n                                       reason:error.description\n                                     userInfo:nil];\n    }\n    \n    error = nil;\n    [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord\n                                           error:&error];\n    if (error) {\n        @throw [NSException exceptionWithName:@\"Category error\"\n                                       reason:error.description\n                                     userInfo:nil];\n    }\n}\n\n- (void)requestRecordPermission\n{\n    switch ([AVAudioSession sharedInstance].recordPermission) {\n        case AVAudioSessionRecordPermissionUndetermined: {\n            // 第一次运行 APP，待定状态\n            UIAlertView *a = [[UIAlertView alloc] initWithTitle:@\"授权提示\"\n                                                        message:@\"你需要授权该 APP 获取音频权限才能录音。\"\n                                                       delegate:self\n                                              cancelButtonTitle:@\"好的，我知道了\"\n                                              otherButtonTitles:nil, nil];\n            [a show];\n            break;\n        }\n\n        case AVAudioSessionRecordPermissionDenied:\n            // 被拒绝过了\n            [self.permissionDelegate didRequestedRecordPermission:NO];\n            break;\n            \n        case AVAudioSessionRecordPermissionGranted: {\n            // 已经被允许\n            [self.permissionDelegate didRequestedRecordPermission:YES];\n            break;\n        }\n            \n        default:\n            break;\n    }\n}\n\n- (void)startRecord\n{\n    self.recorder = [[AVAudioRecorder alloc] initWithURL:[NSURL fileURLWithPath:NSHomeDirectory()]\n                                                settings:nil\n                                                   error:nil];\n    [self.recorder record];\n}\n\n#pragma mark - UIAlertViewDelegate\n- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex\n{\n    [[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) {\n        [self.permissionDelegate didRequestedRecordPermission:granted];\n    }];\n}\n\n#pragma mark - AVAudioSessionRequestRecordPermissionDelegate\n- (void)didRequestedRecordPermission:(BOOL)result\n{\n    if (result) {\n        // Granted\n        NSLog(@\"Granted\");\n        [self startRecord];\n    }\n    else {\n        // Denied\n        NSLog(@\"Denied\");\n        UIAlertView *a = [[UIAlertView alloc] initWithTitle:nil\n                                                    message:@\"没有录音权限，去设置里开启。\"\n                                                   delegate:nil\n                                          cancelButtonTitle:@\"取消\"\n                                          otherButtonTitles: nil, nil];\n        [a show];   // 这个提示框可能要等几秒钟才出来，原因不详。\n    }\n}\n\n@end\n```\n\n\n\n![](/{{path}}2.gif)","slug":"Audio-Session-编程指南-一","published":1,"updated":"2015-07-30T05:02:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicr0hhu5000efj1jgdbl4j5j"},{"title":"App 之间的相互跳转","date":"2015-06-23T05:05:02.000Z","_content":"\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","source":"_posts/App-之间的相互跳转.md","raw":"title: App 之间的相互跳转\ndate: 2015-06-23 13:05:02\ncategories:\n- iOS\ntags: \n- App\n---\n\n不久前公司有个项目需要从我们自己的 Application 跳转到系统WIFI设置界面。google一番后发现一个问题，iOS 在 5.0 版本中开放了 APP 对 System Settings 的链接，开发者可以通过自己的方法实现对 Settings 的定向跳转，代码如下：\n\n{% codeblock lang:objc %}\n\nNSURL *url=[NSURL URLWithString:@\"prefs:root=WIFI\"];\n[[UIApplication sharedApplication] openURL:url];\n\n{% endcodeblock %}\n\n\n不过遗憾的是，Apple 在 5.1 版本中又取消了这一支持。所以目前在项目中添加上述代码，APP 并不会有任何动作（为了考虑简便开发，我们将不再支持 iOS 7.0 以下版本，乔布斯时代总会终结的）。于是本以为这个功能无法实现，但是在使用某些著名的 APP 时发现，它们之中有的确可以从应用程序内跳转到系统设置页，当时就想，shit! 怎么搞的？但是苦于个人技术水平原因，一直弄不清所以然，所以这个问题一直放着，直到昨天整了下 App 和 App 之间的相互跳转，似乎心里有了些眉目。在解决这个问题之前，先看看 App 和 App 互跳是如何实现的。<!--more-->\n\n\n# App 跳转到 App\n\niOS 允许将你的 App 和一个自定义的 URL Scheme 进行绑定，通过该 URL Scheme，你的应用程序可以被浏览器或者其他应用启动，也就是说我们可以在 App1 中通过某个事件响应跳转到 App2。\n\n允许其他应用程序唤起的你的 App，给自己的应用注册一个 URL type 是必要的，这是其他程序跳转过来的入口。这里举例说明，你需要在项目 App1 设置的`info`->`URL Types`中添加一个新项，URL Scheme 随便取名为 App1:\n\n![](/{{path}}1.png)\n\n编译运行以后，你会发现什么都没有发生。的确，这些改动对你的应用程序本身并没有什么可见的影响，但是如果你在 Safari 中的地址栏里输入`App1://`回车之后，浏览器便切回到了 App1。\n\n![](/{{path}}2.gif)\n\n如果浏览器提示`Open this page in \"App1\"`这个是正常的，这个出现的时机不确定，允许就好。\n\n一些网站的二维码下载就是居于这样的原理，扫码以后如果终端没有安装它的应用程序则跳转到 App Store 相关页面，否则直接打开 App。\n\n但是光打开 App 还不够，更多的时候我们希望打开 App 以后跳转到另一个界面里去完成我们想要做得事情，这就需要在跳转的同时把相关的参数也一并传输过来。从上面的动图结合 URL Scheme不难看出应用程序之间传递信息正是依靠 URL 地址进行的。通过 GET 方法提交一个请求，如果待唤醒 App 成功响应了提交的请求，则系统会把这个 App 唤醒送回前台供用户操作，于是可以使用一些自定义的 URL Scheme 传输数据：\n\n> * App1://test?parameter=hello\n* App1://?parameter=hello\n* App1://?hello\n\n上面的这些都是可以的，格式可以按需定义，这个是很自由的，只要能把参数解得出来，随你怎么搞。\n\n既然有了数据的发送者，那自然有数据的接受者。iOS     早期版本提供了`optional func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool`函数用来处理来自其他应用程序的 URL 请求。因此我们可以在这个函数中响应这些请求。但是在这个函数的声明文件中有这么一行注释：\n\n> Will be deprecated at some point, please replace with application:openURL:sourceApplication:annotation:\n\nApple 官方不建议我们使用这个函数，它随时可能被 deprecated，于是我们还有另一个替代方案：`optional func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool`。\n\n| 参数                | 说明             \n| ---------------- | ---------------- \n| application      | 应用程序实例\n| openURL          | 传递过来的 URL\n| sourceApplication | 发出请求的应用程序的 Bundle ID\n| annotation       | 这个参数貌似很牛逼，不过测试几番后仍不知具体有何作用。\n| retutnValue      | 处理成功返回 true， 失败或者没处理返回 false.\n\n<br>\n\n在这个方法里我用一个 UIAlertView 来展示信息:\n\n{% codeblock lang:swift %}\n\nfunc application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {\n    var parameter = url.query\n    var alert = UIAlertView(title: sourceApplication!, message: parameter, delegate: nil, cancelButtonTitle: \"OK\")\n    alert.show()    \n    return true\n}\n\n{% endcodeblock %}\n\n![](/{{path}}3.gif)\n\n<br>\n\n再来看看从 App2 如何跳转到 App1，根据上面的思路，只要在 App2 中发送一个 URL 请求即可。在我的 Storyboard 中有一个 button 和一个 test field 用来发送文本框中得数据，然后在按钮的`touchUpInside`事件中实现主要代码：\n\n{% codeblock lang:swift %}\n\n@IBAction func btnOnClick(sender: UIButton) {\n    if UIApplication.sharedApplication().canOpenURL(NSURL(string: \"App1://\")!){\n        var str = String(format: \"App1://?%@\", msgField.text)\n        str = str.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)!\n        UIApplication.sharedApplication().openURL(NSURL(string: str)!)\n    }\n}\n\n{% endcodeblock %}\n\n![](/{{path}}4.gif)\n\n\n\n# 跳转到系统设置页\n\n上面谈论的都是 用户的 App 之间的跳转，那么 App 跳转到系统设置页该如何去做，毕竟之前的那些方案已经被弃用。`prefs`这个 Scheme 想必是被 Apple 动过了，但是如果你在自己的应用程序里再弄一个 URL Scheme 取名为`prefs`，那么这段代码便活了过来：\n\n![](/{{path}}5.png)\n\n{% codeblock lang:swift %}\n\nclass ViewController: UIViewController {\n    private var arr :[String] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        arr.append(\"\")\n        arr.append(\"prefs:root=WIFI\")\n        arr.append(\"prefs:root=Bluetooth\")\n        arr.append(\"prefs:root=General\")\n        arr.append(\"prefs:root=General&path=About\")\n        arr.append(\"prefs:root=Phone\")\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    @IBAction func execAction(sender: UIButton) {\n        UIApplication.sharedApplication().openURL(NSURL(string: arr[sender.tag])!)\n    }\n\n}\n\n{% endcodeblock %}\n\n![](/{{path}}6.gif)\n\n\n另外 iOS 8 提供了一个方案`UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)!)`用来跳转到设置页。\n\n\n","slug":"App-之间的相互跳转","published":1,"updated":"2015-07-23T02:15:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicr0hhum000ifj1jzgvvj402"}],"PostAsset":[{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/1.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"1.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/10.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"10.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/11.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"11.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/12.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"12.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/13.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"13.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/14.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"14.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/15.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"15.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.gif","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"16.gif","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16.mov","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"16.mov","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/16_mov_poster.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"16_mov_poster.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/2.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"2.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/3.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"3.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/4.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"4.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/5.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"5.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/6.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"6.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/7.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"7.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/8.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"8.png","modified":1},{"_id":"source/_posts/手写一枚优雅的拟物风格圆形进度条/9.png","post":"cicr0hhqh0002fj1jl5m8i0di","slug":"9.png","modified":1},{"_id":"source/_posts/iOS-开发小技巧合集（随时更新）/1.png","post":"cicr0hht60007fj1j4ld6ryhl","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1-1.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"1-1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/1.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"1.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/2.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"2.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/3.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"3.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/4.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"4.png","modified":1},{"_id":"source/_posts/CALayer-的-inner-shadow/5.png","post":"cicr0hhte000bfj1j4lpphoqc","slug":"5.png","modified":1},{"_id":"source/_posts/Audio-Session-编程指南-一/1.png","post":"cicr0hhu5000efj1jgdbl4j5j","slug":"1.png","modified":1},{"_id":"source/_posts/Audio-Session-编程指南-一/2.gif","post":"cicr0hhu5000efj1jgdbl4j5j","slug":"2.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/1.png","post":"cicr0hhum000ifj1jzgvvj402","slug":"1.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/2.gif","post":"cicr0hhum000ifj1jzgvvj402","slug":"2.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/3.gif","post":"cicr0hhum000ifj1jzgvvj402","slug":"3.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/4.gif","post":"cicr0hhum000ifj1jzgvvj402","slug":"4.gif","modified":1},{"_id":"source/_posts/App-之间的相互跳转/5.png","post":"cicr0hhum000ifj1jzgvvj402","slug":"5.png","modified":1},{"_id":"source/_posts/App-之间的相互跳转/6.gif","post":"cicr0hhum000ifj1jzgvvj402","slug":"6.gif","modified":1}],"PostCategory":[{"post_id":"cicr0hhqh0002fj1jl5m8i0di","category_id":"cicr0hhqo0003fj1jokrmpvde","_id":"cicr0hhqq0006fj1je5slwh9g"},{"post_id":"cicr0hht60007fj1j4ld6ryhl","category_id":"cicr0hhqo0003fj1jokrmpvde","_id":"cicr0hht80008fj1j1ygwnz1l"},{"post_id":"cicr0hhte000bfj1j4lpphoqc","category_id":"cicr0hhqo0003fj1jokrmpvde","_id":"cicr0hhtf000cfj1jltg5gnqo"},{"post_id":"cicr0hhu5000efj1jgdbl4j5j","category_id":"cicr0hhqo0003fj1jokrmpvde","_id":"cicr0hhu6000ffj1jf8y2wmqi"},{"post_id":"cicr0hhum000ifj1jzgvvj402","category_id":"cicr0hhqo0003fj1jokrmpvde","_id":"cicr0hhur000jfj1jk1a1our4"}],"PostTag":[{"post_id":"cicr0hhqh0002fj1jl5m8i0di","tag_id":"cicr0hhqo0004fj1jygp4bvqu","_id":"cicr0hhqq0005fj1j8609d6nq"},{"post_id":"cicr0hht60007fj1j4ld6ryhl","tag_id":"cicr0hht80009fj1jg1nswqdb","_id":"cicr0hht9000afj1jefxet7lj"},{"post_id":"cicr0hhte000bfj1j4lpphoqc","tag_id":"cicr0hhqo0004fj1jygp4bvqu","_id":"cicr0hhtg000dfj1j25p6mltk"},{"post_id":"cicr0hhu5000efj1jgdbl4j5j","tag_id":"cicr0hhu6000gfj1j3agieo9w","_id":"cicr0hhu7000hfj1j8w6tjtn2"},{"post_id":"cicr0hhum000ifj1jzgvvj402","tag_id":"cicr0hht80009fj1jg1nswqdb","_id":"cicr0hhur000kfj1jjgcfgkoq"}],"Tag":[{"name":"UI","_id":"cicr0hhqo0004fj1jygp4bvqu"},{"name":"App","_id":"cicr0hht80009fj1jg1nswqdb"},{"name":"Audio","_id":"cicr0hhu6000gfj1j3agieo9w"}]}}